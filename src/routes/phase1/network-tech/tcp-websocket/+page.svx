---
title: "TCP/WebSocketæ¥ç¶šç¢ºç«‹ã®è©³ç´°"
description: "TCP/WebSocketã®æ¥ç¶šç¢ºç«‹ãƒ—ãƒ­ã‚»ã‚¹ã®æŠ€è¡“çš„è©³ç´°ã‚’å®Œå…¨ç†è§£ã™ã‚‹"
duration: "2-3æ™‚é–“"
difficulty: "ä¸­ç´š"
---

<script>
  import LessonLayout from '$lib/components/common/LessonLayout.svelte';
  import Section from '$lib/components/common/Section.svelte';
  import Card from '$lib/components/common/Card.svelte';
  import MermaidLazyLoad from '$lib/components/MermaidLazyLoad.svelte';
</script>

<LessonLayout
  lessonId="phase1-network-tech-tcp-websocket"
  title="TCP/WebSocketæ¥ç¶šç¢ºç«‹ã®è©³ç´°"
  duration="2-3æ™‚é–“"
  difficulty="ä¸­ç´š"
  prerequisites={['HTTPåŸºç¤', 'OSIå‚ç…§ãƒ¢ãƒ‡ãƒ«', 'TCP/IPåŸºç¤çŸ¥è­˜', 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹æˆç†è§£']}
  sectionTitle="ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æŠ€è¡“åŸºç¤"
  nextLessonId="phase1-network-tech-security-ports"
  nextLessonTitle="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒãƒ¼ãƒˆç®¡ç†"
  nextLessonPath="/phase1/network-tech/security-ports"
  learningObjectives={[
    'TCPæ¥ç¶šç¢ºç«‹ã®3-wayãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‹ã‚‰WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã¾ã§ã®å®Œå…¨ãªæµã‚Œã‚’ç†è§£',
    'End-to-Endé€šä¿¡ã¨Hop-by-Hopé€šä¿¡ã®æŠ€è¡“çš„é•ã„ã¨WebSocketã§ã®å®Ÿè£…è©³ç´°',
    'HTTP/1.1 Upgradeãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®è©³ç´°ä»•æ§˜ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…',
    'ãƒ—ãƒ­ã‚­ã‚·ãƒ»ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ»NATç’°å¢ƒã§ã®WebSocketæ¥ç¶šç¢ºç«‹æ‰‹æ³•',
    'WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®å®Ÿè£…ä¾‹ã¨ãƒ‡ãƒãƒƒã‚°æ‰‹æ³•ã®ç¿’å¾—'
  ]}
>

<Section title="TCPæ¥ç¶šç¢ºç«‹ã®åŸºç¤" icon="concept">

<Card title="TCPã®3-wayãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯è©³ç´°" icon="info" accentColor="blue">

WebSocketæ¥ç¶šã‚’ç†è§£ã™ã‚‹ã«ã¯ã€ã¾ãšãã®åŸºç›¤ã¨ãªã‚‹TCPæ¥ç¶šç¢ºç«‹ã®è©³ç´°ã‚’ç†è§£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

<MermaidLazyLoad chart={`
sequenceDiagram
    participant C as ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    participant S as ã‚µãƒ¼ãƒãƒ¼
    
    Note over C,S: TCPæ¥ç¶šç¢ºç«‹ï¼ˆ3-wayãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ï¼‰
    
    C->>S: SYN (seq=100)
    Note right of C: æ¥ç¶šè¦æ±‚<br/>åˆæœŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ç•ªå·:100
    
    S->>C: SYN-ACK (seq=200, ack=101)
    Note left of S: æ¥ç¶šæ‰¿èª<br/>åˆæœŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ç•ªå·:200<br/>ç¢ºèªå¿œç­”ç•ªå·:101
    
    C->>S: ACK (seq=101, ack=201)
    Note right of C: ç¢ºèªå¿œç­”<br/>æ¥ç¶šç¢ºç«‹å®Œäº†
    
    Note over C,S: TCPæ¥ç¶šç¢ºç«‹å®Œäº†<br/>ã“ã®ä¸Šã§HTTPé€šä¿¡é–‹å§‹
`} />

#### TCPæ¥ç¶šç¢ºç«‹ã®é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ

- **SYNï¼ˆSynchronizeï¼‰**ï¼šæ¥ç¶šç¢ºç«‹è¦æ±‚ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ç•ªå·ã‚’é€šçŸ¥
- **SYN-ACK**ï¼šæ¥ç¶šæ‰¿èªã€‚ã‚µãƒ¼ãƒãƒ¼ã®åˆæœŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ç•ªå·ã¨ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ç•ªå·ã¸ã®ç¢ºèªå¿œç­”
- **ACKï¼ˆAcknowledgmentï¼‰**ï¼šæœ€çµ‚ç¢ºèªã€‚åŒæ–¹å‘ã®æ¥ç¶šç¢ºç«‹å®Œäº†

**WebSocketã¸ã®å½±éŸ¿**ï¼šWebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã¯ã€ã“ã®ç¢ºç«‹æ¸ˆã¿TCPæ¥ç¶šä¸Šã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

</Card>

<Card title="WebSocketæ¥ç¶šç¢ºç«‹ã®å…¨ä½“ãƒ•ãƒ­ãƒ¼" icon="lightning" accentColor="green">

WebSocketæ¥ç¶šç¢ºç«‹ã¯ã€TCPæ¥ç¶šã®ä¸Šã§è¡Œã‚ã‚Œã‚‹å¤šæ®µéšãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚

<MermaidLazyLoad chart={`
sequenceDiagram
    participant C as ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    participant P as ãƒ—ãƒ­ã‚­ã‚·
    participant S as ã‚µãƒ¼ãƒãƒ¼
    
    Note over C,S: Phase 1: TCPæ¥ç¶šç¢ºç«‹
    C->>S: TCP 3-way handshake
    Note over C,S: TCPæ¥ç¶šç¢ºç«‹å®Œäº†
    
    Note over C,S: Phase 2: HTTPãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯
    C->>P: GET /ws HTTP/1.1<br/>Connection: Upgrade<br/>Upgrade: websocket<br/>Sec-WebSocket-Key: xxx
    P->>S: åŒã˜ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è»¢é€
    
    S->>P: HTTP/1.1 101 Switching Protocols<br/>Sec-WebSocket-Accept: yyy
    P->>C: åŒã˜ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è»¢é€
    
    Note over C,S: Phase 3: WebSocketé€šä¿¡é–‹å§‹
    C->>S: WebSocketãƒ•ãƒ¬ãƒ¼ãƒ é€šä¿¡
    S->>C: WebSocketãƒ•ãƒ¬ãƒ¼ãƒ é€šä¿¡
`} />

#### æ¥ç¶šç¢ºç«‹ã®å„æ®µéšã®è©³ç´°

1. **TCPæ¥ç¶šç¢ºç«‹**ï¼šåŸºç›¤ã¨ãªã‚‹ä¿¡é ¼æ€§ã®ã‚ã‚‹åŒæ–¹å‘é€šä¿¡è·¯ã‚’ç¢ºç«‹
2. **HTTPãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯**ï¼šWebSocketãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¸ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰äº¤æ¸‰
3. **WebSocketé€šä¿¡**ï¼šãƒ•ãƒ¬ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹ã®åŒæ–¹å‘ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡é–‹å§‹

</Card>

</Section>

<Section title="End-to-End vs Hop-by-Hopé€šä¿¡ã®è©³ç´°" icon="demo">

<Card title="é€šä¿¡ãƒ¢ãƒ‡ãƒ«ã®æŠ€è¡“çš„é•ã„" icon="check" accentColor="blue">

ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é€šä¿¡ã«ã¯2ã¤ã®åŸºæœ¬çš„ãªãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚Šã€WebSocketã¨HTTPã§ã¯ãã‚Œãã‚Œç•°ãªã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚

<MermaidLazyLoad chart={`
flowchart TD
    subgraph "Hop-by-Hopé€šä¿¡ï¼ˆå¾“æ¥ã®HTTPï¼‰"
        C1[ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] -->|å€‹åˆ¥æ¥ç¶š| P1[ãƒ—ãƒ­ã‚­ã‚·]
        P1 -->|å€‹åˆ¥æ¥ç¶š| R1[ãƒ«ãƒ¼ã‚¿ãƒ¼]
        R1 -->|å€‹åˆ¥æ¥ç¶š| S1[ã‚µãƒ¼ãƒãƒ¼]
        
        C1 -.->|ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†| P1
        P1 -.->|ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»å¤‰æ›| R1
        R1 -.->|ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚¹| S1
    end
    
    subgraph "End-to-Endé€šä¿¡ï¼ˆWebSocketï¼‰"
        C2[ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] ==>|è«–ç†çš„ãªç›´æ¥æ¥ç¶š| S2[ã‚µãƒ¼ãƒãƒ¼]
        P2[ãƒ—ãƒ­ã‚­ã‚·] -.->|é€éçš„è»¢é€| Transparent[é€éçš„è»¢é€ã®ã¿]
        R2[ãƒ«ãƒ¼ã‚¿ãƒ¼] -.->|é€éçš„è»¢é€| Transparent
    end
`} />

</Card>

<Card title="Hop-by-Hopé€šä¿¡ã®è©³ç´°å®Ÿè£…" icon="warning" accentColor="orange">

å¾“æ¥ã®HTTPé€šä¿¡ã§ã¯ã€å„ä¸­é–“ãƒãƒ¼ãƒ‰ãŒç‹¬ç«‹ã—ã¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†ã—ã¾ã™ã€‚

#### å®Ÿè¡Œç’°å¢ƒ

```
Node.js: 18.x ä»¥ä¸Š
å¿…è¦ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸: http, url, crypto
å®Ÿè¡Œæ–¹æ³•: node proxy-server.js
```

```javascript
// ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã§ã®HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ä¾‹
class HTTPProxy {
  async handleRequest(request) {
    // 1. ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®è§£æã¨å¤‰æ›´
    const modifiedRequest = this.modifyHeaders(request);
    
    // 2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
    const cachedResponse = await this.checkCache(request.url);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // 3. ä¸Šæµã‚µãƒ¼ãƒãƒ¼ã¸ã®æ–°ã—ã„æ¥ç¶š
    const upstreamConnection = await this.createConnection(targetServer);
    const response = await upstreamConnection.send(modifiedRequest);
    
    // 4. ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å¤‰æ›´ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    const modifiedResponse = this.modifyResponse(response);
    await this.cacheResponse(request.url, modifiedResponse);
    
    return modifiedResponse;
  }
  
  modifyHeaders(request) {
    // ãƒ—ãƒ­ã‚­ã‚·ãŒç‹¬è‡ªã«ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ ãƒ»å¤‰æ›´
    request.headers['X-Forwarded-For'] = getClientIP();
    request.headers['X-Proxy-Authorization'] = getProxyAuth();
    return request;
  }
}
```

#### Hop-by-Hopé€šä¿¡ã®ç‰¹å¾´

- **ç‹¬ç«‹ã—ãŸå‡¦ç†**ï¼šå„ä¸­é–“ãƒãƒ¼ãƒ‰ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ç‹¬ç«‹ã—ã¦å‡¦ç†
- **çŠ¶æ…‹ç®¡ç†ä¸è¦**ï¼šå„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ç‹¬ç«‹ã—ã¦ãŠã‚Šã€å‰å›ã®çŠ¶æ…‹ã‚’ä¿æŒã—ãªã„
- **æŸ”è»Ÿãªå¤‰æ›´**ï¼šãƒ—ãƒ­ã‚­ã‚·ã§ãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€èªè¨¼å‡¦ç†ãŒå¯èƒ½
- **æ¥ç¶šã®ç‹¬ç«‹æ€§**ï¼šã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ-ãƒ—ãƒ­ã‚­ã‚·é–“ã¨ãƒ—ãƒ­ã‚­ã‚·-ã‚µãƒ¼ãƒãƒ¼é–“ã¯åˆ¥ã€…ã®æ¥ç¶š

</Card>

<Card title="End-to-Endé€šä¿¡ã®è©³ç´°å®Ÿè£…" icon="lightning" accentColor="green">

WebSocketã§ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒãƒ¼é–“ã«è«–ç†çš„ãªç›´æ¥æ¥ç¶šã‚’ç¢ºç«‹ã—ã¾ã™ã€‚

```javascript
// WebSocketæ¥ç¶šã§ã®End-to-Endé€šä¿¡å®Ÿè£…
class WebSocketEndToEnd {
  constructor(url) {
    this.url = url;
    this.connectionState = 'disconnected';
  }
  
  async establishConnection() {
    // 1. TCPãƒ¬ãƒ™ãƒ«ã§ã®æ¥ç¶šç¢ºç«‹ï¼ˆãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§ã‚‚è«–ç†çš„ã«ã¯ç›´æ¥ï¼‰
    const tcpConnection = await this.establishTCP();
    
    // 2. HTTP Upgradeãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯
    const upgradeSuccess = await this.performUpgrade(tcpConnection);
    
    if (upgradeSuccess) {
      // 3. End-to-Endæ¥ç¶šç¢ºç«‹å®Œäº†
      this.connectionState = 'connected';
      this.setupFrameHandling(tcpConnection);
    }
  }
  
  async performUpgrade(connection) {
    // WebSocketã‚­ãƒ¼ã®ç”Ÿæˆï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´èªè¨¼ï¼‰
    const wsKey = this.generateWebSocketKey();
    
    const upgradeRequest = {
      method: 'GET',
      headers: {
        'Connection': 'Upgrade',
        'Upgrade': 'websocket',
        'Sec-WebSocket-Version': '13',
        'Sec-WebSocket-Key': wsKey
      }
    };
    
    const response = await connection.send(upgradeRequest);
    
    // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”ã‚­ãƒ¼æ¤œè¨¼
    const expectedAccept = this.calculateExpectedAccept(wsKey);
    return response.headers['Sec-WebSocket-Accept'] === expectedAccept;
  }
  
  setupFrameHandling(connection) {
    // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã§ã®ç›´æ¥é€šä¿¡é–‹å§‹
    connection.onMessage = (frame) => {
      // ãƒ—ãƒ­ã‚­ã‚·ã«ã‚ˆã‚‹å¤‰æ›´ãªã—ã€ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾å—ä¿¡
      this.handleWebSocketFrame(frame);
    };
  }
  
  sendMessage(data) {
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç›´æ¥ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ï¼ˆä¸­é–“ãƒãƒ¼ãƒ‰ã¯é€éçš„è»¢é€ã®ã¿ï¼‰
    const frame = this.createWebSocketFrame(data);
    this.connection.send(frame);
  }
}
```

#### End-to-Endé€šä¿¡ã®ç‰¹å¾´

- **è«–ç†çš„ç›´æ¥æ¥ç¶š**ï¼šä¸­é–“ãƒãƒ¼ãƒ‰ã¯é€éçš„ãªè»¢é€ã®ã¿å®Ÿè¡Œ
- **çŠ¶æ…‹ä¿æŒ**ï¼šæ¥ç¶šç¢ºç«‹å¾Œã€ãã®çŠ¶æ…‹ã‚’ç¶™ç¶šçš„ã«ç¶­æŒ
- **ãƒ•ãƒ¬ãƒ¼ãƒ æ•´åˆæ€§**ï¼šé€ä¿¡ã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ãŒãã®ã¾ã¾å®›å…ˆã«åˆ°é”
- **ä½é…å»¶**ï¼šä¸­é–“ãƒãƒ¼ãƒ‰ã§ã®å‡¦ç†ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãŒæœ€å°é™

</Card>

<Card title="å®Ÿéš›ã®ãƒ—ãƒ­ã‚­ã‚·ç’°å¢ƒã§ã®å‹•ä½œæ¯”è¼ƒ" icon="star" accentColor="purple">

ä¼æ¥­ç’°å¢ƒãªã©ã§ä¸€èˆ¬çš„ãªãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã‚’é€šã—ãŸé€šä¿¡ã®é•ã„ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

<MermaidLazyLoad chart={`
sequenceDiagram
    participant C as ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    participant P as ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼
    participant S as ã‚µãƒ¼ãƒãƒ¼
    
    Note over C,S: HTTPé€šä¿¡ï¼ˆHop-by-Hopï¼‰
    C->>P: GET /api/data HTTP/1.1<br/>Host: server.com
    Note over P: ãƒ—ãƒ­ã‚­ã‚·ã§ã®å‡¦ç†<br/>ãƒ»èªè¨¼ãƒã‚§ãƒƒã‚¯<br/>ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª<br/>ãƒ»ãƒ˜ãƒƒãƒ€ãƒ¼å¤‰æ›´
    P->>S: GET /api/data HTTP/1.1<br/>Host: server.com<br/>X-Forwarded-For: client_ip<br/>Proxy-Authorization: xxx
    S-->>P: 200 OK + ãƒ‡ãƒ¼ã‚¿
    Note over P: ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†<br/>ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜<br/>ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ•ã‚£ãƒ«ã‚¿
    P-->>C: 200 OK + å¤‰æ›´ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
    
    Note over C,S: WebSocketé€šä¿¡ï¼ˆEnd-to-Endï¼‰
    C->>P: GET /ws HTTP/1.1<br/>Connection: Upgrade<br/>Upgrade: websocket
    P->>S: åŒã˜ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€éçš„è»¢é€
    S-->>P: 101 Switching Protocols
    P-->>C: é€éçš„è»¢é€ï¼ˆå¤‰æ›´ãªã—ï¼‰
    
    Note over C,S: WebSocketãƒ•ãƒ¬ãƒ¼ãƒ é€šä¿¡é–‹å§‹
    C->>S: WebSocketãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆé€éçš„è»¢é€ï¼‰
    S->>C: WebSocketãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆé€éçš„è»¢é€ï¼‰
`} />

#### ãƒ—ãƒ­ã‚­ã‚·ç’°å¢ƒã§ã®é‡è¦ãªé•ã„

**HTTPï¼ˆHop-by-Hopï¼‰**
- ãƒ—ãƒ­ã‚­ã‚·ãŒå„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è§£é‡ˆãƒ»å¤‰æ›´å¯èƒ½
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€èªè¨¼ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŒé©ç”¨ã•ã‚Œã‚‹
- ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹

**WebSocketï¼ˆEnd-to-Endï¼‰**
- ãƒ—ãƒ­ã‚­ã‚·ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è§£é‡ˆã›ãšã€ãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦é€éçš„ã«è»¢é€
- ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯å¾Œã¯ãƒ—ãƒ­ã‚­ã‚·ã«ã‚ˆã‚‹å¤‰æ›´ãŒä¸å¯èƒ½
- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒãƒ¼é–“ã®ç›´æ¥çš„ãªãƒ‡ãƒ¼ã‚¿äº¤æ›

</Card>

</Section>

<Section title="HTTP/1.1 Upgradeãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®è©³ç´°å®Ÿè£…" icon="implementation">

<Card title="ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®å®Œå…¨ãªä»•æ§˜" icon="warning" accentColor="blue">

WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã¯ã€RFC 6455ã§å®šç¾©ã•ã‚ŒãŸå³å¯†ãªä»•æ§˜ã«å¾“ã£ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

#### 1. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯å®Ÿè£…

#### å®Ÿè¡Œç’°å¢ƒ

```
Node.js: 18.x ä»¥ä¸Š
å¿…è¦ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸: ws, crypto, net
ãƒ–ãƒ©ã‚¦ã‚¶: ã™ã¹ã¦ã®ãƒ¢ãƒ€ãƒ³ãƒ–ãƒ©ã‚¦ã‚¶
å®Ÿè¡Œæ–¹æ³•: node websocket-client.js
```

```javascript
class WebSocketClient {
  async initiateHandshake(url) {
    // WebSocketã‚­ãƒ¼ã®ç”Ÿæˆ
    const wsKey = this.generateSecWebSocketKey();
    
    // ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ§‹ç¯‰
    const request = this.buildHandshakeRequest(url, wsKey);
    
    // TCPã‚½ã‚±ãƒƒãƒˆçµŒç”±ã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
    const response = await this.sendHandshakeRequest(request);
    
    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ¤œè¨¼
    if (this.validateHandshakeResponse(response, wsKey)) {
      return this.establishWebSocketConnection();
    } else {
      throw new Error('WebSocket handshake failed');
    }
  }
  
  generateSecWebSocketKey() {
    // 16ãƒã‚¤ãƒˆã®ãƒ©ãƒ³ãƒ€ãƒ å€¤ã‚’ç”Ÿæˆã—ã¦Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
    const randomBytes = new Uint8Array(16);
    crypto.getRandomValues(randomBytes);
    return btoa(String.fromCharCode(...randomBytes));
  }
  
  buildHandshakeRequest(url, wsKey) {
    const urlObj = new URL(url);
    
    return [
      `GET ${urlObj.pathname} HTTP/1.1`,
      `Host: ${urlObj.host}`,
      `Upgrade: websocket`,
      `Connection: Upgrade`,
      `Sec-WebSocket-Key: ${wsKey}`,
      `Sec-WebSocket-Version: 13`,
      `Origin: ${window.location.origin}`,
      '', // ç©ºè¡Œã§ãƒ˜ãƒƒãƒ€ãƒ¼çµ‚äº†
      ''
    ].join('\r\n');
  }
  
  validateHandshakeResponse(response, originalKey) {
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ç¢ºèª
    if (!response.startsWith('HTTP/1.1 101 Switching Protocols')) {
      return false;
    }
    
    // å¿…é ˆãƒ˜ãƒƒãƒ€ãƒ¼ã®ç¢ºèª
    const headers = this.parseHeaders(response);
    
    if (headers['upgrade'] !== 'websocket' || 
        headers['connection'].toLowerCase() !== 'upgrade') {
      return false;
    }
    
    // Sec-WebSocket-Acceptã®æ¤œè¨¼
    const expectedAccept = this.calculateAcceptKey(originalKey);
    return headers['sec-websocket-accept'] === expectedAccept;
  }
  
  calculateAcceptKey(wsKey) {
    // RFC 6455ã§å®šç¾©ã•ã‚ŒãŸWebSocket magic string
    const magicString = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
    const concatenated = wsKey + magicString;
    
    // SHA-1ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ã—ã¦Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
    const hash = this.sha1(concatenated);
    return btoa(hash);
  }
}
```

</Card>

<Card title="ã‚µãƒ¼ãƒãƒ¼å´ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯å®Ÿè£…" icon="check" accentColor="green">

```javascript
class WebSocketServer {
  handleHandshakeRequest(request, socket) {
    try {
      // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®è§£æ
      const headers = this.parseHandshakeRequest(request);
      
      // ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®æ¤œè¨¼
      if (!this.validateHandshakeRequest(headers)) {
        this.sendHandshakeError(socket, 400, 'Bad Request');
        return false;
      }
      
      // Sec-WebSocket-Acceptã®è¨ˆç®—
      const wsKey = headers['sec-websocket-key'];
      const acceptKey = this.calculateAcceptKey(wsKey);
      
      // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®é€ä¿¡
      const response = this.buildHandshakeResponse(acceptKey, headers);
      socket.write(response);
      
      // WebSocketæ¥ç¶šçŠ¶æ…‹ã«ç§»è¡Œ
      this.upgradeToWebSocket(socket);
      return true;
      
    } catch (error) {
      this.sendHandshakeError(socket, 500, 'Internal Server Error');
      return false;
    }
  }
  
  validateHandshakeRequest(headers) {
    // å¿…é ˆãƒ˜ãƒƒãƒ€ãƒ¼ã®ç¢ºèª
    const requiredHeaders = [
      'host',
      'upgrade',
      'connection',
      'sec-websocket-key',
      'sec-websocket-version'
    ];
    
    for (const header of requiredHeaders) {
      if (!headers[header]) {
        return false;
      }
    }
    
    // ãƒ˜ãƒƒãƒ€ãƒ¼å€¤ã®æ¤œè¨¼
    if (headers['upgrade'] !== 'websocket' ||
        !headers['connection'].toLowerCase().includes('upgrade') ||
        headers['sec-websocket-version'] !== '13') {
      return false;
    }
    
    // WebSocketã‚­ãƒ¼ã®å½¢å¼ç¢ºèª
    if (!this.isValidWebSocketKey(headers['sec-websocket-key'])) {
      return false;
    }
    
    return true;
  }
  
  isValidWebSocketKey(key) {
    // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ16ãƒã‚¤ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‹ãƒã‚§ãƒƒã‚¯
    try {
      const decoded = atob(key);
      return decoded.length === 16;
    } catch (e) {
      return false;
    }
  }
  
  buildHandshakeResponse(acceptKey, requestHeaders) {
    let response = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${acceptKey}`
    ];
    
    // ã‚µãƒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å‡¦ç†
    if (requestHeaders['sec-websocket-protocol']) {
      const supportedProtocol = this.selectSubprotocol(
        requestHeaders['sec-websocket-protocol']
      );
      if (supportedProtocol) {
        response.push(`Sec-WebSocket-Protocol: ${supportedProtocol}`);
      }
    }
    
    // æ‹¡å¼µã®å‡¦ç†
    if (requestHeaders['sec-websocket-extensions']) {
      const supportedExtensions = this.selectExtensions(
        requestHeaders['sec-websocket-extensions']
      );
      if (supportedExtensions) {
        response.push(`Sec-WebSocket-Extensions: ${supportedExtensions}`);
      }
    }
    
    response.push('', ''); // ç©ºè¡Œã§ãƒ˜ãƒƒãƒ€ãƒ¼çµ‚äº†
    return response.join('\r\n');
  }
}
```

</Card>

<Card title="ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼" icon="star" accentColor="yellow">

WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã«ã¯ã€æ„å›³ã—ãªã„æ¥ç¶šã‚’é˜²ããŸã‚ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚

#### Sec-WebSocket-Keyã«ã‚ˆã‚‹æ¤œè¨¼ãƒ¡ã‚«ãƒ‹ã‚ºãƒ 

```javascript
class HandshakeSecurity {
  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚­ãƒ¼ã®ç”Ÿæˆã¨æ¤œè¨¼ã®è©³ç´°
  static demonstrateKeyGeneration() {
    // 1. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒãƒ©ãƒ³ãƒ€ãƒ ã‚­ãƒ¼ã‚’ç”Ÿæˆ
    const clientKey = 'dGhlIHNhbXBsZSBub25jZQ==';
    console.log('Client Key:', clientKey);
    
    // 2. ã‚µãƒ¼ãƒãƒ¼ãŒAcceptã‚­ãƒ¼ã‚’è¨ˆç®—
    const magicString = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
    const concatenated = clientKey + magicString;
    console.log('Concatenated:', concatenated);
    
    // 3. SHA-1ãƒãƒƒã‚·ãƒ¥è¨ˆç®—
    const sha1Hash = this.sha1(concatenated);
    console.log('SHA-1 Hash:', sha1Hash);
    
    // 4. Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
    const acceptKey = btoa(sha1Hash);
    console.log('Accept Key:', acceptKey);
    
    return acceptKey;
  }
  
  // ã‚ªãƒªã‚¸ãƒ³ãƒ™ãƒ¼ã‚¹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
  static validateOrigin(origin, allowedOrigins) {
    if (!allowedOrigins || allowedOrigins.length === 0) {
      return true; // ã‚ªãƒªã‚¸ãƒ³åˆ¶é™ãªã—
    }
    
    // å³å¯†ãªã‚ªãƒªã‚¸ãƒ³ç…§åˆ
    if (allowedOrigins.includes(origin)) {
      return true;
    }
    
    // ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ç…§åˆ
    for (const allowed of allowedOrigins) {
      if (allowed.startsWith('*.')) {
        const domain = allowed.substring(2);
        if (origin.endsWith('.' + domain) || origin === domain) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  // CSRFãƒˆãƒ¼ã‚¯ãƒ³ã«ã‚ˆã‚‹è¿½åŠ ä¿è­·
  static validateCSRFToken(headers, expectedToken) {
    const token = headers['x-csrf-token'] || headers['x-requested-with'];
    return token === expectedToken;
  }
}
```

#### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼ã®é‡è¦æ€§

- **æ„å›³ã—ãªã„æ¥ç¶šã®é˜²æ­¢**ï¼šãƒ©ãƒ³ãƒ€ãƒ ã‚­ãƒ¼æ¤œè¨¼ã«ã‚ˆã‚Šã€æ„å›³çš„ãªWebSocketæ¥ç¶šã®ã¿ã‚’è¨±å¯
- **ã‚ªãƒªã‚¸ãƒ³åˆ¶é™**ï¼šä¿¡é ¼ã§ãã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‹ã‚‰ã®æ¥ç¶šã®ã¿ã‚’å—ã‘å…¥ã‚Œ
- **CSRFæ”»æ’ƒã®é˜²æ­¢**ï¼šè¿½åŠ çš„ãªãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼ã§ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒªã‚’é˜²ã

</Card>

</Section>

<Section title="ãƒ—ãƒ­ã‚­ã‚·ãƒ»ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ç’°å¢ƒã§ã®æ¥ç¶šç¢ºç«‹" icon="theory">

<Card title="ä¼æ¥­ç’°å¢ƒã§ã®WebSocketæ¥ç¶šèª²é¡Œ" icon="warning" accentColor="orange">

ä¼æ¥­ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§ã¯ã€ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã‚„ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãŒWebSocketæ¥ç¶šã«å½±éŸ¿ã‚’ä¸ãˆã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

#### ä¸€èˆ¬çš„ãªä¼æ¥­ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹æˆ

```mermaid
flowchart TD
    subgraph "ä¼æ¥­å†…ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯"
        Client[ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] --> ProxyCluster["ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼"]
        
        subgraph ProxyCluster ["ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼"]
            HTTP_Proxy[HTTP Proxy<br/>ï¼ˆCONNECTå¯¾å¿œï¼‰]
            SOCKS_Proxy[SOCKS Proxy<br/>ï¼ˆé€éçš„è»¢é€ï¼‰]
            App_Proxy[ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³<br/>ãƒ¬ãƒ™ãƒ«ãƒ—ãƒ­ã‚­ã‚·]
        end

        ProxyCluster --> Firewall[ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«]
        Firewall --> NAT[NAT/Router]
    end
    
    subgraph "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ"
        NAT --> Internet[ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ]
        Internet --> Target[WebSocketã‚µãƒ¼ãƒãƒ¼]
    end
```

</Card>

<Card title="HTTPãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã®WebSocketæ¥ç¶š" icon="check" accentColor="blue">

HTTPãƒ—ãƒ­ã‚­ã‚·ç’°å¢ƒã§ã¯ã€HTTP CONNECTãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒˆãƒ³ãƒãƒ«æ¥ç¶šã‚’ç¢ºç«‹ã—ã¾ã™ã€‚

```javascript
class ProxyWebSocketConnection {
  async connectThroughHTTPProxy(wsUrl, proxyConfig) {
    const wsTarget = new URL(wsUrl);
    
    // 1. ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã¸ã®TCPæ¥ç¶š
    const proxySocket = await this.connectToProxy(proxyConfig);
    
    // 2. HTTP CONNECTãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ãƒˆãƒ³ãƒãƒ«ç¢ºç«‹
    const tunnelEstablished = await this.establishTunnel(
      proxySocket, 
      wsTarget.host
    );
    
    if (!tunnelEstablished) {
      throw new Error('Failed to establish proxy tunnel');
    }
    
    // 3. ãƒˆãƒ³ãƒãƒ«çµŒç”±ã§WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯
    return this.performWebSocketHandshake(proxySocket, wsUrl);
  }
  
  async establishTunnel(socket, targetHost) {
    // HTTP CONNECT ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
    const connectRequest = [
      `CONNECT ${targetHost} HTTP/1.1`,
      `Host: ${targetHost}`,
      `Proxy-Connection: keep-alive`,
      '',
      ''
    ].join('\r\n');
    
    socket.write(connectRequest);
    
    // ãƒ—ãƒ­ã‚­ã‚·ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹å¾…æ©Ÿ
    const response = await this.readResponse(socket);
    
    // æ¥ç¶šæˆåŠŸç¢ºèª
    if (response.startsWith('HTTP/1.1 200')) {
      console.log('Proxy tunnel established successfully');
      return true;
    } else {
      console.error('Proxy tunnel failed:', response);
      return false;
    }
  }
  
  async performWebSocketHandshake(socket, wsUrl) {
    // ç¢ºç«‹ã•ã‚ŒãŸãƒˆãƒ³ãƒãƒ«çµŒç”±ã§WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯å®Ÿè¡Œ
    const wsKey = this.generateWebSocketKey();
    const url = new URL(wsUrl);
    
    const handshakeRequest = [
      `GET ${url.pathname} HTTP/1.1`,
      `Host: ${url.host}`,
      `Upgrade: websocket`,
      `Connection: Upgrade`,
      `Sec-WebSocket-Key: ${wsKey}`,
      `Sec-WebSocket-Version: 13`,
      '',
      ''
    ].join('\r\n');
    
    socket.write(handshakeRequest);
    
    const response = await this.readResponse(socket);
    return this.validateWebSocketUpgrade(response, wsKey);
  }
}
```

#### HTTP CONNECTãƒ¡ã‚½ãƒƒãƒ‰ã®è©³ç´°

- **ç›®çš„**ï¼šãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã‚’é€šã˜ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚µãƒ¼ãƒãƒ¼ã¸ã®é€éçš„ãªãƒˆãƒ³ãƒãƒ«ã‚’ç¢ºç«‹
- **å‹•ä½œ**ï¼šãƒ—ãƒ­ã‚­ã‚·ãŒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒãƒ¼é–“ã®ãƒã‚¤ãƒˆåˆ—ã‚’å˜ç´”è»¢é€
- **åˆ©ç‚¹**ï¼šWebSocketãƒ•ãƒ¬ãƒ¼ãƒ ãŒãƒ—ãƒ­ã‚­ã‚·ã§è§£é‡ˆã•ã‚Œã‚‹ã“ã¨ãªãã€ãã®ã¾ã¾è»¢é€ã•ã‚Œã‚‹

</Card>

<Card title="SOCKSãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã®æ¥ç¶š" icon="lightning" accentColor="green">

SOCKSãƒ—ãƒ­ã‚­ã‚·ã¯ã€ã‚ˆã‚Šä½ãƒ¬ãƒ™ãƒ«ã§ã®é€éçš„ãªæ¥ç¶šã‚’æä¾›ã—ã¾ã™ã€‚

```javascript
class SOCKSWebSocketConnection {
  async connectThroughSOCKS5(wsUrl, socksConfig) {
    const wsTarget = new URL(wsUrl);
    
    // 1. SOCKSãƒ—ãƒ­ã‚­ã‚·ã¸ã®æ¥ç¶š
    const socksSocket = await this.connectToSOCKS(socksConfig);
    
    // 2. SOCKS5èªè¨¼
    await this.authenticateSOCKS5(socksSocket, socksConfig);
    
    // 3. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šè¦æ±‚
    await this.requestSOCKSConnection(socksSocket, wsTarget);
    
    // 4. é€éçš„æ¥ç¶šç¢ºç«‹å¾Œã€ç›´æ¥WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯
    return this.performDirectWebSocketHandshake(socksSocket, wsUrl);
  }
  
  async authenticateSOCKS5(socket, config) {
    // SOCKS5èªè¨¼ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
    const authRequest = new Uint8Array([
      0x05, // SOCKS version 5
      0x01, // Number of authentication methods
      0x02  // Username/Password authentication
    ]);
    
    socket.write(authRequest);
    
    const authResponse = await this.readBytes(socket, 2);
    if (authResponse[1] !== 0x02) {
      throw new Error('SOCKS5 authentication method not supported');
    }
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼å/ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼
    const credentials = this.buildCredentials(config.username, config.password);
    socket.write(credentials);
    
    const authResult = await this.readBytes(socket, 2);
    if (authResult[1] !== 0x00) {
      throw new Error('SOCKS5 authentication failed');
    }
  }
  
  async requestSOCKSConnection(socket, target) {
    // SOCKS5æ¥ç¶šè¦æ±‚
    const hostname = target.hostname;
    const port = parseInt(target.port) || (target.protocol === 'wss:' ? 443 : 80);
    
    const connectRequest = new Uint8Array([
      0x05, // SOCKS version
      0x01, // Connect command
      0x00, // Reserved
      0x03, // Domain name address type
      hostname.length, // Domain name length
      ...new TextEncoder().encode(hostname), // Domain name
      (port >> 8) & 0xFF, // Port high byte
      port & 0xFF         // Port low byte
    ]);
    
    socket.write(connectRequest);
    
    const connectResponse = await this.readBytes(socket, 10);
    if (connectResponse[1] !== 0x00) {
      throw new Error('SOCKS5 connection failed');
    }
    
    console.log('SOCKS5 connection established');
  }
}
```

#### SOCKSãƒ—ãƒ­ã‚­ã‚·ã®åˆ©ç‚¹

- **é€éæ€§**ï¼šã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«ã§ã®å¤‰æ›´ãŒä¸è¦
- **ãƒ—ãƒ­ãƒˆã‚³ãƒ«éä¾å­˜**ï¼šHTTPä»¥å¤–ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã‚‚ä½¿ç”¨å¯èƒ½
- **ä½ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰**ï¼šæœ€å°é™ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«å‡¦ç†

</Card>

<Card title="ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ»NATç’°å¢ƒã§ã®è€ƒæ…®äº‹é …" icon="star" accentColor="purple">

```javascript
class FirewallAwareWebSocket {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      // ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«å¯¾å¿œè¨­å®š
      keepaliveInterval: options.keepaliveInterval || 30000,
      maxReconnectAttempts: options.maxReconnectAttempts || 5,
      reconnectDelay: options.reconnectDelay || 1000,
      useSecureConnection: options.useSecureConnection !== false,
      
      // NATç’°å¢ƒå¯¾å¿œ
      enableHeartbeat: options.enableHeartbeat !== false,
      heartbeatInterval: options.heartbeatInterval || 25000,
      
      ...options
    };
  }
  
  async connect() {
    // ã‚»ã‚­ãƒ¥ã‚¢æ¥ç¶šã®å¼·åˆ¶ï¼ˆãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«é€šéç‡å‘ä¸Šï¼‰
    if (this.options.useSecureConnection) {
      this.url = this.url.replace('ws://', 'wss://');
    }
    
    // æ¨™æº–HTTPSãƒãƒ¼ãƒˆä½¿ç”¨ï¼ˆãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«åˆ¶é™å›é¿ï¼‰
    if (this.options.useStandardPorts) {
      this.url = this.url.replace(/:8080/, ':443');
    }
    
    return this.establishConnectionWithRetry();
  }
  
  async establishConnectionWithRetry() {
    let attempts = 0;
    
    while (attempts < this.options.maxReconnectAttempts) {
      try {
        const connection = await this.attemptConnection();
        
        // æ¥ç¶šæˆåŠŸæ™‚ã®è¨­å®š
        this.setupKeepalive(connection);
        this.setupHeartbeat(connection);
        
        return connection;
        
      } catch (error) {
        attempts++;
        console.log(`Connection attempt ${attempts} failed:`, error.message);
        
        if (attempts < this.options.maxReconnectAttempts) {
          // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§å†è©¦è¡Œ
          const delay = this.options.reconnectDelay * Math.pow(2, attempts - 1);
          await this.sleep(delay);
        }
      }
    }
    
    throw new Error('Failed to establish WebSocket connection after maximum attempts');
  }
  
  setupKeepalive(connection) {
    // NATçŠ¶æ…‹ãƒ†ãƒ¼ãƒ–ãƒ«ç¶­æŒã®ãŸã‚ã®ã‚­ãƒ¼ãƒ—ã‚¢ãƒ©ã‚¤ãƒ–
    this.keepaliveTimer = setInterval(() => {
      if (connection.readyState === WebSocket.OPEN) {
        connection.ping(); // WebSocket pingãƒ•ãƒ¬ãƒ¼ãƒ é€ä¿¡
      }
    }, this.options.keepaliveInterval);
  }
  
  setupHeartbeat(connection) {
    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«ã®ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆ
    this.heartbeatTimer = setInterval(() => {
      if (connection.readyState === WebSocket.OPEN) {
        connection.send(JSON.stringify({
          type: 'heartbeat',
          timestamp: Date.now()
        }));
      }
    }, this.options.heartbeatInterval);
  }
}
```

#### ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ç’°å¢ƒã§ã®æœ€é©åŒ–

- **æ¨™æº–ãƒãƒ¼ãƒˆä½¿ç”¨**ï¼š80/443ãƒãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«åˆ¶é™ã‚’å›é¿
- **WSSå¼·åˆ¶**ï¼šæš—å·åŒ–æ¥ç¶šã§DPIï¼ˆDeep Packet Inspectionï¼‰åˆ¶é™ã‚’å›é¿
- **ã‚­ãƒ¼ãƒ—ã‚¢ãƒ©ã‚¤ãƒ–**ï¼šNATçŠ¶æ…‹ãƒ†ãƒ¼ãƒ–ãƒ«ã®ç¶­æŒã§æ¥ç¶šæ–­ã‚’é˜²æ­¢
- **å†æ¥ç¶šæˆ¦ç•¥**ï¼šãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ³ã«å¿œã˜ãŸé©å¿œçš„å†æ¥ç¶š

</Card>

</Section>

<Section title="å®Ÿè·µçš„ãªãƒ‡ãƒãƒƒã‚°ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°" icon="practice">

<Card title="WebSocketæ¥ç¶šã®ãƒ‡ãƒãƒƒã‚°æ‰‹æ³•" icon="check" accentColor="green">

å®Ÿéš›ã®é–‹ç™ºã§ã¯ã€æ¥ç¶šå•é¡Œã®è¨ºæ–­ã¨è§£æ±ºãŒé‡è¦ãªã‚¹ã‚­ãƒ«ã¨ãªã‚Šã¾ã™ã€‚

```javascript
class WebSocketDebugger {
  static enableDebugLogging() {
    // è©³ç´°ãªæ¥ç¶šãƒ­ã‚°ã‚’æœ‰åŠ¹åŒ–
    const originalWebSocket = window.WebSocket;
    
    window.WebSocket = class extends originalWebSocket {
      constructor(url, protocols) {
        console.log('ğŸ”Œ WebSocketæ¥ç¶šé–‹å§‹:', { url, protocols });
        super(url, protocols);
        
        this.addEventListener('open', (event) => {
          console.log('âœ… WebSocketæ¥ç¶šæˆåŠŸ:', {
            url: this.url,
            protocol: this.protocol,
            extensions: this.extensions,
            timestamp: new Date().toISOString()
          });
        });
        
        this.addEventListener('error', (event) => {
          console.error('âŒ WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼:', {
            url: this.url,
            readyState: this.readyState,
            event: event,
            timestamp: new Date().toISOString()
          });
          
          // ã‚¨ãƒ©ãƒ¼è©³ç´°åˆ†æ
          this.analyzeConnectionError();
        });
        
        this.addEventListener('close', (event) => {
          console.log('ğŸ”Œ WebSocketæ¥ç¶šã‚¯ãƒ­ãƒ¼ã‚º:', {
            code: event.code,
            reason: event.reason,
            wasClean: event.wasClean,
            timestamp: new Date().toISOString()
          });
          
          // ã‚¯ãƒ­ãƒ¼ã‚ºç†ç”±ã®è©³ç´°è§£æ
          this.analyzeCloseReason(event.code);
        });
      }
      
      analyzeConnectionError() {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨ºæ–­
        this.checkNetworkConnectivity();
        
        // ãƒ—ãƒ­ã‚­ã‚·è¨­å®šç¢ºèª
        this.checkProxyConfiguration();
        
        // ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨ºæ–­
        this.checkFirewallRestrictions();
      }
      
      analyzeCloseReason(code) {
        const closeReasons = {
          1000: 'æ­£å¸¸çµ‚äº†',
          1001: 'ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆé›¢è„±',
          1002: 'ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¨ãƒ©ãƒ¼',
          1003: 'ä¸æ­£ãªãƒ‡ãƒ¼ã‚¿å—ä¿¡',
          1006: 'ç•°å¸¸çµ‚äº†ï¼ˆè©³ç´°ä¸æ˜ï¼‰',
          1007: 'ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚¨ãƒ©ãƒ¼',
          1008: 'ãƒãƒªã‚·ãƒ¼é•å',
          1009: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚µã‚¤ã‚ºéå¤§',
          1010: 'æ‹¡å¼µãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—',
          1011: 'ã‚µãƒ¼ãƒãƒ¼å†…éƒ¨ã‚¨ãƒ©ãƒ¼'
        };
        
        console.log('ã‚¯ãƒ­ãƒ¼ã‚ºç†ç”±:', closeReasons[code] || `ä¸æ˜ï¼ˆã‚³ãƒ¼ãƒ‰: ${code}ï¼‰`);
        
        // å†æ¥ç¶šæ¨å¥¨åˆ¤å®š
        if ([1006, 1011, 1012, 1013, 1014, 1015].includes(code)) {
          console.log('ğŸ’¡ æ¨å¥¨: å†æ¥ç¶šã‚’è©¦è¡Œã—ã¦ãã ã•ã„');
        }
      }
      
      async checkNetworkConnectivity() {
        try {
          const response = await fetch('https://httpbin.org/get', {
            method: 'GET',
            mode: 'cors'
          });
          
          if (response.ok) {
            console.log('âœ… åŸºæœ¬çš„ãªHTTPæ¥ç¶šã¯æ­£å¸¸');
          }
        } catch (error) {
          console.error('âŒ åŸºæœ¬çš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã«å•é¡Œ:', error);
        }
      }
      
      checkProxyConfiguration() {
        // ãƒ—ãƒ­ã‚­ã‚·è¨­å®šã®æ¨å®š
        const navigator = window.navigator;
        
        if (navigator.connection) {
          console.log('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æƒ…å ±:', {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt
          });
        }
        
        // ãƒ—ãƒ­ã‚­ã‚·å­˜åœ¨ã®é–“æ¥çš„æ¤œå‡º
        const userAgent = navigator.userAgent;
        if (userAgent.includes('Proxy') || userAgent.includes('Gateway')) {
          console.log('ğŸ’¡ ãƒ—ãƒ­ã‚­ã‚·ã¾ãŸã¯ã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ã®å­˜åœ¨ãŒç–‘ã‚ã‚Œã¾ã™');
        }
      }
    };
  }
  
  static async performConnectionDiagnostics(url) {
    console.log('ğŸ” WebSocketæ¥ç¶šè¨ºæ–­ã‚’é–‹å§‹:', url);
    
    const diagnostics = {
      timestamp: new Date().toISOString(),
      url: url,
      results: {}
    };
    
    // 1. URLå½¢å¼ã®æ¤œè¨¼
    diagnostics.results.urlValidation = this.validateWebSocketURL(url);
    
    // 2. DNSè§£æ±ºãƒ†ã‚¹ãƒˆ
    diagnostics.results.dnsResolution = await this.testDNSResolution(url);
    
    // 3. TCPæ¥ç¶šãƒ†ã‚¹ãƒˆ
    diagnostics.results.tcpConnectivity = await this.testTCPConnectivity(url);
    
    // 4. HTTPæ¥ç¶šãƒ†ã‚¹ãƒˆ
    diagnostics.results.httpConnectivity = await this.testHTTPConnectivity(url);
    
    // 5. WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ãƒ†ã‚¹ãƒˆ
    diagnostics.results.websocketHandshake = await this.testWebSocketHandshake(url);
    
    console.log('ğŸ” è¨ºæ–­çµæœ:', diagnostics);
    return diagnostics;
  }
  
  static validateWebSocketURL(url) {
    try {
      const wsUrl = new URL(url);
      
      const validation = {
        isValid: true,
        protocol: wsUrl.protocol,
        hostname: wsUrl.hostname,
        port: wsUrl.port,
        pathname: wsUrl.pathname,
        issues: []
      };
      
      if (!['ws:', 'wss:'].includes(wsUrl.protocol)) {
        validation.isValid = false;
        validation.issues.push('ç„¡åŠ¹ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«: ' + wsUrl.protocol);
      }
      
      if (!wsUrl.hostname) {
        validation.isValid = false;
        validation.issues.push('ãƒ›ã‚¹ãƒˆåãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
      }
      
      return validation;
      
    } catch (error) {
      return {
        isValid: false,
        error: error.message,
        issues: ['URLå½¢å¼ãŒç„¡åŠ¹ã§ã™']
      };
    }
  }
}

// ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã®æœ‰åŠ¹åŒ–
WebSocketDebugger.enableDebugLogging();
```

</Card>

<Card title="æ¥ç¶šå•é¡Œã®ç³»çµ±çš„è§£æ±ºæ³•" icon="star" accentColor="purple">

```javascript
class WebSocketTroubleshooter {
  static async diagnoseConnectionFailure(url, error) {
    console.log('ğŸ”§ æ¥ç¶šå•é¡Œã®è¨ºæ–­ã‚’é–‹å§‹');
    
    const troubleshootingSteps = [];
    
    // Step 1: ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã®åˆ†é¡
    const errorType = this.classifyError(error);
    troubleshootingSteps.push(`ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—: ${errorType}`);
    
    // Step 2: ç’°å¢ƒå›ºæœ‰ã®å•é¡Œãƒã‚§ãƒƒã‚¯
    const environmentIssues = await this.checkEnvironmentIssues();
    troubleshootingSteps.push(...environmentIssues);
    
    // Step 3: æ®µéšçš„æ¥ç¶šãƒ†ã‚¹ãƒˆ
    const connectionTests = await this.performStepByStepTests(url);
    troubleshootingSteps.push(...connectionTests);
    
    // Step 4: è§£æ±ºç­–ã®ææ¡ˆ
    const solutions = this.proposeSolutions(errorType, environmentIssues);
    
    return {
      diagnosis: troubleshootingSteps,
      solutions: solutions,
      timestamp: new Date().toISOString()
    };
  }
  
  static classifyError(error) {
    if (error.name === 'SecurityError') {
      return 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ã‚¨ãƒ©ãƒ¼';
    } else if (error.message?.includes('network')) {
      return 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚¨ãƒ©ãƒ¼';
    } else if (error.message?.includes('timeout')) {
      return 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼';
    } else if (error.message?.includes('refused')) {
      return 'æ¥ç¶šæ‹’å¦ã‚¨ãƒ©ãƒ¼';
    } else {
      return 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
    }
  }
  
  static async checkEnvironmentIssues() {
    const issues = [];
    
    // ãƒ–ãƒ©ã‚¦ã‚¶ã‚µãƒãƒ¼ãƒˆç¢ºèª
    if (!window.WebSocket) {
      issues.push('âŒ WebSocketãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
    } else {
      issues.push('âœ… WebSocketã‚µãƒãƒ¼ãƒˆç¢ºèªæ¸ˆã¿');
    }
    
    // HTTPS/HTTPã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç¢ºèª
    if (location.protocol === 'https:') {
      issues.push('âœ… ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼ˆHTTPSï¼‰');
    } else {
      issues.push('âš ï¸ éã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼ˆHTTPï¼‰- wssãƒ—ãƒ­ãƒˆã‚³ãƒ«åˆ¶é™ã®å¯èƒ½æ€§');
    }
    
    // ä¼æ¥­ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¤œå‡º
    const isEnterpriseNetwork = await this.detectEnterpriseNetwork();
    if (isEnterpriseNetwork) {
      issues.push('âš ï¸ ä¼æ¥­ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç’°å¢ƒ - ãƒ—ãƒ­ã‚­ã‚·ãƒ»ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«åˆ¶é™ã®å¯èƒ½æ€§');
    }
    
    return issues;
  }
  
  static proposeSolutions(errorType, environmentIssues) {
    const solutions = [];
    
    switch (errorType) {
      case 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ã‚¨ãƒ©ãƒ¼':
        solutions.push('1. HTTPSã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§wssãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½¿ç”¨');
        solutions.push('2. é©åˆ‡ãªCORSãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚µãƒ¼ãƒãƒ¼ã§è¨­å®š');
        solutions.push('3. ä¿¡é ¼ã§ãã‚‹ã‚ªãƒªã‚¸ãƒ³ã‹ã‚‰æ¥ç¶š');
        break;
        
      case 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚¨ãƒ©ãƒ¼':
        solutions.push('1. ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèª');
        solutions.push('2. DNSã‚µãƒ¼ãƒãƒ¼è¨­å®šã‚’ç¢ºèª');
        solutions.push('3. ãƒ—ãƒ­ã‚­ã‚·è¨­å®šã‚’ç¢ºèª');
        break;
        
      case 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼':
        solutions.push('1. æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã‚’å»¶é•·');
        solutions.push('2. ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ã‚’ç¢ºèª');
        solutions.push('3. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é…å»¶ã‚’æ¸¬å®š');
        break;
        
      case 'æ¥ç¶šæ‹’å¦ã‚¨ãƒ©ãƒ¼':
        solutions.push('1. ã‚µãƒ¼ãƒãƒ¼ãŒç¨¼åƒä¸­ã‹ç¢ºèª');
        solutions.push('2. ãƒãƒ¼ãƒˆç•ªå·ãŒæ­£ã—ã„ã‹ç¢ºèª');
        solutions.push('3. ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šã‚’ç¢ºèª');
        break;
    }
    
    // ç’°å¢ƒå›ºæœ‰ã®è§£æ±ºç­–
    if (environmentIssues.some(issue => issue.includes('ä¼æ¥­ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯'))) {
      solutions.push('ä¼æ¥­ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¯¾ç­–:');
      solutions.push('- æ¨™æº–ãƒãƒ¼ãƒˆï¼ˆ80/443ï¼‰ã‚’ä½¿ç”¨');
      solutions.push('- WSSãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å¼·åˆ¶ä½¿ç”¨');
      solutions.push('- ãƒ—ãƒ­ã‚­ã‚·è¨­å®šã®ç¢ºèªãƒ»é©ç”¨');
    }
    
    return solutions;
  }
}
```

</Card>

<Card title="å­¦ç¿’ã®ç·æ‹¬ã¨æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—" icon="check" accentColor="indigo">

#### ã“ã®ãƒ¬ãƒƒã‚¹ãƒ³ã§ç¿’å¾—ã—ãŸé‡è¦ãªã‚¹ã‚­ãƒ«

**æŠ€è¡“çš„ãªæ·±ã„ç†è§£**
- âœ… TCP 3-wayãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‹ã‚‰WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã¾ã§ã®å®Œå…¨ãªæµã‚Œ
- âœ… End-to-Endé€šä¿¡ã¨Hop-by-Hopé€šä¿¡ã®å®Ÿè£…ãƒ¬ãƒ™ãƒ«ã§ã®é•ã„
- âœ… HTTP/1.1 Upgradeãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®è©³ç´°ä»•æ§˜ã¨å®Ÿè£…
- âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚­ãƒ¼ç”Ÿæˆãƒ»æ¤œè¨¼ã®æš—å·å­¦çš„åŸºç¤

**å®Ÿè·µçš„ãªå•é¡Œè§£æ±ºèƒ½åŠ›**
- âœ… ãƒ—ãƒ­ã‚­ã‚·ç’°å¢ƒï¼ˆHTTP CONNECTã€SOCKSï¼‰ã§ã®æ¥ç¶šç¢ºç«‹æ‰‹æ³•
- âœ… ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ»NATç’°å¢ƒã§ã®æœ€é©åŒ–æˆ¦ç•¥
- âœ… ç³»çµ±çš„ãªãƒ‡ãƒãƒƒã‚°ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æ‰‹æ³•
- âœ… ä¼æ¥­ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç’°å¢ƒã§ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

#### æ¬¡ã®ãƒ¬ãƒƒã‚¹ãƒ³ã¸ã®æº–å‚™

ã“ã®ãƒ¬ãƒƒã‚¹ãƒ³ã§å­¦ã‚“ã æ¥ç¶šç¢ºç«‹ã®çŸ¥è­˜ã¯ã€æ¬¡ã®ã€Œã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒãƒ¼ãƒˆç®¡ç†ã€ãƒ¬ãƒƒã‚¹ãƒ³ã§ä»¥ä¸‹ã®ç™ºå±•çš„ãƒˆãƒ”ãƒƒã‚¯ã«æ´»ç”¨ã•ã‚Œã¾ã™ã€‚

- **èªè¨¼ãƒ»èªå¯ãƒ¡ã‚«ãƒ‹ã‚ºãƒ **ï¼šã‚»ã‚­ãƒ¥ã‚¢ãªWebSocketæ¥ç¶šã®å®Ÿè£…
- **è¨¼æ˜æ›¸ç®¡ç†**ï¼šTLS/SSLå±¤ã§ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–
- **æ”»æ’ƒé˜²å¾¡**ï¼šDDoSã€ä¸­é–“è€…æ”»æ’ƒãªã©ã¸ã®å¯¾ç­–
- **ç›£æŸ»ãƒ»ãƒ­ã‚°**ï¼šã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ã¨ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å¯¾å¿œ

</Card>

</Section>

</LessonLayout>