---
title: "HTTP/1.1ã‹ã‚‰HTTP/3ã¾ã§ã®WebSocketå¯¾å¿œ"
description: "HTTPã®å„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ãŠã‘ã‚‹WebSocketå¯¾å¿œçŠ¶æ³ã¨ç‰¹å¾´ã‚’æ¯”è¼ƒã—ã€æœ€é©ãªå®Ÿè£…æˆ¦ç•¥ã‚’å­¦ç¿’ã—ã¾ã™"
duration: "1.5-2æ™‚é–“"
difficulty: "ä¸­ç´š"
phase: 1
lesson: "2.3"
---

<script>
	import LessonLayout from '$lib/components/common/LessonLayout.svelte';
	import Section from '$lib/components/common/Section.svelte';
	import Card from '$lib/components/common/Card.svelte';
</script>

<LessonLayout
	lessonId="phase1-network-tech-http-versions"
	title="HTTP/1.1ã‹ã‚‰HTTP/3ã¾ã§ã®WebSocketå¯¾å¿œ"
	duration="1.5-2æ™‚é–“"
	difficulty="ä¸­ç´š"
	prerequisites={['HTTPåŸºç¤', 'OSIå‚ç…§ãƒ¢ãƒ‡ãƒ«', 'TCP/WebSocketæ¥ç¶šç¢ºç«‹ãƒ—ãƒ­ã‚»ã‚¹']}
	sectionTitle="ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æŠ€è¡“åŸºç¤"
	nextLessonId="phase1-network-tech-tcp-websocket"
	nextLessonTitle="TCPã¨WebSocketã®é–¢ä¿‚"
	nextLessonPath="/phase1/network-tech/tcp-websocket"
	learningObjectives={[
		'HTTPã®å„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ãŠã‘ã‚‹WebSocketå¯¾å¿œçŠ¶æ³ã®è©³ç´°ç†è§£',
		'HTTP/2ã§ã®åŒæ–¹å‘é€šä¿¡æ©Ÿèƒ½ã¨WebSocketã¨ã®æŠ€è¡“çš„å·®ç•°ã®æŠŠæ¡',
		'HTTP/3ï¼ˆQUICï¼‰ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨WebSocketã®çµ±åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç†è§£',
		'2025å¹´ç¾åœ¨ã®æ¨å¥¨å®Ÿè£…æˆ¦ç•¥ã¨å°†æ¥ã¸ã®ç§»è¡Œè¨ˆç”»ã®ç­–å®š'
	]}
>

<Section title="å­¦ç¿’å†…å®¹" icon="ğŸ“š">
	<Card title="ã“ã®ãƒ¬ãƒƒã‚¹ãƒ³ã§å­¦ã¶ã“ã¨" icon="ğŸ“‹" accentColor="blue">
		<p>HTTPãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é€²åŒ–ã¨WebSocketæŠ€è¡“ã®é–¢ä¿‚ã‚’æ·±ãç†è§£ã—ã€å®Ÿè·µçš„ãªå®Ÿè£…æˆ¦ç•¥ã‚’ç¿’å¾—ã—ã¾ã™ã€‚</p>
		<ul>
			<li><strong>HTTP/1.1ãƒ™ãƒ¼ã‚¹WebSocket</strong>ã®è©³ç´°ãªå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³</li>
			<li><strong>HTTP/2 Server Push vs WebSocket</strong>ã®æŠ€è¡“çš„æ¯”è¼ƒã¨é¸æŠåŸºæº–</li>
			<li><strong>HTTP/3ï¼ˆQUICï¼‰</strong>ã§ã®æ–°ã—ã„WebSocketå®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ</li>
			<li><strong>WebTransport</strong>ã«ã‚ˆã‚‹æ¬¡ä¸–ä»£åŒæ–¹å‘é€šä¿¡ã®å±•æœ›</li>
			<li><strong>2025å¹´ã®æ¨å¥¨æˆ¦ç•¥</strong>ã¨å®Ÿè£…ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³</li>
		</ul>
	</Card>
</Section>

<Section title="HTTP/1.1ã¨WebSocketï¼šåŸºç›¤æŠ€è¡“" icon="ğŸ”„">

<Card title="WebSocketã®æ ¹å¹¹ãƒ—ãƒ­ãƒˆã‚³ãƒ«" icon="ğŸŒ" accentColor="green">

**HTTP/1.1**ã¯ç¾åœ¨ã®WebSocketå®Ÿè£…ã®åŸºç›¤ã¨ãªã‚‹æœ€ã‚‚é‡è¦ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚

### WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®è©³ç´°

**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ãƒªã‚¯ã‚¨ã‚¹ãƒˆ**
```http
GET /chat HTTP/1.1
Host: example.com:8080
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
Origin: https://example.com
User-Agent: Mozilla/5.0 (compatible WebSocket client)
```

**ã‚µãƒ¼ãƒãƒ¼å´ãƒ¬ã‚¹ãƒãƒ³ã‚¹**
```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
Sec-WebSocket-Extensions: permessage-deflate
```

### HTTP/1.1 Upgradeãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®å®Ÿè£…

```javascript
// ã‚µãƒ¼ãƒãƒ¼å´ï¼šNode.js + ws ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã®å®Ÿè£…
const WebSocket = require('ws');
const http = require('http');

class HTTP11WebSocketServer {
  constructor() {
    this.server = http.createServer();
    this.wss = new WebSocket.Server({
      server: this.server,
      handleProtocols: this.handleProtocols.bind(this),
      verifyClient: this.verifyClient.bind(this)
    });
    
    this.setupHTTP11Handling();
  }
  
  setupHTTP11Handling() {
    // HTTP/1.1ç‰¹æœ‰ã®å‡¦ç†
    this.server.on('upgrade', (request, socket, head) => {
      console.log('HTTP/1.1 Upgrade request received');
      console.log('Headers:', request.headers);
      
      // WebSocketãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã®è©³ç´°ãƒ­ã‚°
      this.logUpgradeDetails(request);
      
      // WebSocketã‚µãƒ¼ãƒãƒ¼ã«ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰å‡¦ç†ã‚’å§”ä»»
      this.wss.handleUpgrade(request, socket, head, (ws) => {
        this.wss.emit('connection', ws, request);
      });
    });
  }
  
  handleProtocols(protocols, request) {
    console.log('Requested protocols:', protocols);
    
    // ãƒ—ãƒ­ãƒˆã‚³ãƒ«é¸æŠãƒ­ã‚¸ãƒƒã‚¯
    const supportedProtocols = ['chat', 'echo', 'binary'];
    for (const protocol of protocols) {
      if (supportedProtocols.includes(protocol)) {
        return protocol;
      }
    }
    
    return false; // ãƒ—ãƒ­ãƒˆã‚³ãƒ«æ‹’å¦
  }
  
  verifyClient(info) {
    // HTTP/1.1ãƒ™ãƒ¼ã‚¹ã®æ¤œè¨¼
    const { origin, secure, req } = info;
    
    console.log('Client verification:', {
      origin,
      secure,
      userAgent: req.headers['user-agent'],
      httpVersion: req.httpVersion
    });
    
    // HTTP/1.1ã®è©³ç´°æ¤œè¨¼
    if (req.httpVersion !== '1.1') {
      console.log('Rejected: Not HTTP/1.1');
      return false;
    }
    
    return true;
  }
  
  logUpgradeDetails(request) {
    console.log('=== HTTP/1.1 WebSocket Upgrade Details ===');
    console.log('HTTP Version:', request.httpVersion);
    console.log('Method:', request.method);
    console.log('URL:', request.url);
    console.log('Upgrade header:', request.headers.upgrade);
    console.log('Connection header:', request.headers.connection);
    console.log('WebSocket Key:', request.headers['sec-websocket-key']);
    console.log('WebSocket Version:', request.headers['sec-websocket-version']);
  }
}
```

### HTTP/1.1ã®æŠ€è¡“çš„å„ªä½æ€§

<div class="mt-4 p-4 bg-green-50 rounded-lg">
<h5 class="font-medium text-green-800">âœ… HTTP/1.1WebSocketã®å¼·ã¿</h5>
<ul class="text-sm text-green-700 mt-2 space-y-1">
<li>â€¢ **å®Œå…¨ãªWebSocket RFC 6455å¯¾å¿œ**ï¼šã™ã¹ã¦ã®æ©Ÿèƒ½ã‚’ç¶²ç¾…</li>
<li>â€¢ **æœ€ã‚‚å®‰å®šã—ãŸå®Ÿè£…**ï¼š10å¹´ä»¥ä¸Šã®å®Ÿç¸¾ã¨ãƒã‚°ä¿®æ­£</li>
<li>â€¢ **å…¨ãƒ–ãƒ©ã‚¦ã‚¶ã‚µãƒãƒ¼ãƒˆ**ï¼šIE10ä»¥é™ã€å…¨ãƒ¢ãƒ€ãƒ³ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œ</li>
<li>â€¢ **è±Šå¯Œãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ»ãƒ„ãƒ¼ãƒ«**ï¼šå¤šè¨€èªã§ã®æˆç†Ÿã—ãŸå®Ÿè£…</li>
<li>â€¢ **ãƒ‡ãƒãƒƒã‚°ã®å®¹æ˜“ã•**ï¼šHTTP/1.1ã¯äººé–“ãŒèª­ã¿ã‚„ã™ã„å½¢å¼</li>
</ul>
</div>

</Card>

<Card title="HTTP/1.1 WebSocketã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³" icon="âš™ï¸" accentColor="blue">

### ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§ã®æ¨å¥¨å®Ÿè£…

```javascript
// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ï¼šå …ç‰¢ãªWebSocketå®Ÿè£…
class ProductionWebSocket {
  constructor(url, options = {}) {
    this.url = url;
    this.options = {
      protocols: options.protocols || [],
      reconnectInterval: options.reconnectInterval || 3000,
      maxReconnectAttempts: options.maxReconnectAttempts || 10,
      heartbeatInterval: options.heartbeatInterval || 30000,
      ...options
    };
    
    this.reconnectAttempts = 0;
    this.isConnected = false;
    this.messageQueue = [];
    
    this.connect();
  }
  
  connect() {
    try {
      // HTTP/1.1ãƒ™ãƒ¼ã‚¹WebSocketæ¥ç¶š
      this.ws = new WebSocket(this.url, this.options.protocols);
      
      // HTTP/1.1å›ºæœ‰ã®ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
      this.ws.onopen = this.handleOpen.bind(this);
      this.ws.onmessage = this.handleMessage.bind(this);
      this.ws.onclose = this.handleClose.bind(this);
      this.ws.onerror = this.handleError.bind(this);
      
    } catch (error) {
      console.error('WebSocket connection failed:', error);
      this.scheduleReconnect();
    }
  }
  
  handleOpen(event) {
    console.log('HTTP/1.1 WebSocket connected');
    this.isConnected = true;
    this.reconnectAttempts = 0;
    
    // HTTP/1.1æ¥ç¶šã®è©³ç´°ãƒ­ã‚°
    console.log('Protocol selected:', this.ws.protocol);
    console.log('Extensions:', this.ws.extensions);
    
    // ã‚­ãƒ¥ãƒ¼ã«è“„ç©ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
    this.flushMessageQueue();
    
    // ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆé–‹å§‹
    this.startHeartbeat();
  }
  
  handleMessage(event) {
    try {
      const data = JSON.parse(event.data);
      
      // ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆå¿œç­”ã®å‡¦ç†
      if (data.type === 'pong') {
        this.lastPongTime = Date.now();
        return;
      }
      
      // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
      this.onMessage?.(data);
      
    } catch (error) {
      console.error('Message parsing error:', error);
    }
  }
  
  handleClose(event) {
    console.log('WebSocket connection closed:', event.code, event.reason);
    this.isConnected = false;
    this.stopHeartbeat();
    
    // HTTP/1.1ç‰¹æœ‰ã®ã‚¯ãƒ­ãƒ¼ã‚ºã‚³ãƒ¼ãƒ‰å‡¦ç†
    this.handleCloseCode(event.code);
    
    // è‡ªå‹•å†æ¥ç¶š
    if (this.shouldReconnect(event.code)) {
      this.scheduleReconnect();
    }
  }
  
  handleCloseCode(code) {
    const closeCodes = {
      1000: 'Normal Closure',
      1001: 'Going Away',
      1002: 'Protocol Error',
      1003: 'Unsupported Data',
      1005: 'No Status Received',
      1006: 'Abnormal Closure',
      1007: 'Invalid frame payload data',
      1008: 'Policy Violation',
      1009: 'Message Too Big',
      1010: 'Mandatory Extension',
      1011: 'Internal Server Error',
      1015: 'TLS Handshake'
    };
    
    console.log(`Close code ${code}: ${closeCodes[code] || 'Unknown'}`);
  }
  
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected) {
        this.send({ type: 'ping', timestamp: Date.now() });
      }
    }, this.options.heartbeatInterval);
  }
  
  send(data) {
    const message = JSON.stringify(data);
    
    if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(message);
    } else {
      // æ¥ç¶šã—ã¦ã„ãªã„å ´åˆã¯ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
      this.messageQueue.push(message);
    }
  }
}
```

### HTTP/1.1ã§ã®é«˜åº¦ãªæ©Ÿèƒ½å®Ÿè£…

```javascript
// ã‚µãƒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒ»æ‹¡å¼µæ©Ÿèƒ½ã®æ´»ç”¨
class AdvancedHTTP11WebSocket {
  constructor(url) {
    this.url = url;
    this.setupAdvancedFeatures();
  }
  
  setupAdvancedFeatures() {
    // è¤‡æ•°ã®ã‚µãƒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã®å¯¾å¿œ
    const protocols = [
      'chat-v1',      // ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ£ãƒƒãƒˆ
      'binary-v1',    // ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿
      'json-rpc-2.0'  // JSON-RPC
    ];
    
    // æ‹¡å¼µæ©Ÿèƒ½ã®è¦æ±‚
    // permessage-deflate: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸åœ§ç¸®
    // x-webkit-deflate-frame: Safariå¯¾å¿œ
    this.ws = new WebSocket(this.url, protocols);
    
    this.ws.onopen = () => {
      console.log('Selected protocol:', this.ws.protocol);
      console.log('Available extensions:', this.ws.extensions);
      
      // ãƒ—ãƒ­ãƒˆã‚³ãƒ«åˆ¥ã®åˆæœŸåŒ–
      this.initializeProtocol(this.ws.protocol);
    };
  }
  
  initializeProtocol(protocol) {
    switch (protocol) {
      case 'chat-v1':
        this.setupChatProtocol();
        break;
      case 'binary-v1':
        this.setupBinaryProtocol();
        break;
      case 'json-rpc-2.0':
        this.setupJsonRpcProtocol();
        break;
    }
  }
  
  setupChatProtocol() {
    // ãƒãƒ£ãƒƒãƒˆãƒ—ãƒ­ãƒˆã‚³ãƒ«å›ºæœ‰ã®å‡¦ç†
    this.messageHandlers = {
      'chat.message': this.handleChatMessage.bind(this),
      'chat.typing': this.handleTypingIndicator.bind(this),
      'chat.user_joined': this.handleUserJoined.bind(this)
    };
  }
  
  setupBinaryProtocol() {
    // ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿å‡¦ç†
    this.ws.binaryType = 'arraybuffer';
    this.binaryHandlers = {
      image: this.handleImageData.bind(this),
      audio: this.handleAudioData.bind(this),
      file: this.handleFileTransfer.bind(this)
    };
  }
  
  // åœ§ç¸®æ©Ÿèƒ½ã®æ´»ç”¨
  sendCompressedMessage(data) {
    // permessage-deflateæ‹¡å¼µãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
    if (this.ws.extensions.includes('permessage-deflate')) {
      // å¤§ããªãƒ‡ãƒ¼ã‚¿ã®å ´åˆã€è‡ªå‹•çš„ã«åœ§ç¸®ã•ã‚Œã‚‹
      this.ws.send(JSON.stringify(data));
    } else {
      // æ‰‹å‹•åœ§ç¸®ã®å®Ÿè£…
      this.sendManuallyCompressed(data);
    }
  }
}
```

</Card>

</Section>

<Section title="HTTP/2ã§ã®åŒæ–¹å‘é€šä¿¡ã¨WebSocket" icon="âš¡">

<Card title="HTTP/2 Server Push vs WebSocketï¼šæŠ€è¡“çš„æ¯”è¼ƒ" icon="ğŸ”€" accentColor="orange">

**HTTP/2**ã¯åŒæ–¹å‘é€šä¿¡æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ãŒã€WebSocketã¨ã¯æ ¹æœ¬çš„ã«ç•°ãªã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã™ã€‚

### HTTP/2 Server Pushã®æŠ€è¡“çš„åˆ¶é™

```javascript
// HTTP/2 Server Pushï¼ˆç¾åœ¨ã¯éæ¨å¥¨ï¼‰
// æ³¨æ„ï¼šå¤šãã®ãƒ–ãƒ©ã‚¦ã‚¶ã§å»ƒæ­¢ã•ã‚Œã¦ã„ã¾ã™
class HTTP2ServerPush {
  constructor() {
    // HTTP/2 Server Pushã®ä»•çµ„ã¿
    this.limitations = {
      direction: 'ä¸€æ–¹å‘ï¼ˆã‚µãƒ¼ãƒãƒ¼ â†’ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼‰',
      model: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹',
      state: 'ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹',
      timing: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆäºˆæ¸¬ãƒ™ãƒ¼ã‚¹'
    };
  }
  
  // HTTP/2 Server Pushã®å®Ÿè£…ä¾‹
  setupServerPush(response) {
    // ã“ã®æ©Ÿèƒ½ã¯å¤šãã®ãƒ–ãƒ©ã‚¦ã‚¶ã§å»ƒæ­¢æ¸ˆã¿
    if (response.stream.pushAllowed) {
      response.stream.pushStream({
        ':path': '/api/updates',
        ':method': 'GET'
      }, (err, pushStream) => {
        if (err) {
          console.error('Server Push failed:', err);
          return;
        }
        
        pushStream.respond({
          ':status': 200,
          'content-type': 'application/json'
        });
        
        pushStream.end(JSON.stringify({
          type: 'update',
          data: 'Server pushed data'
        }));
      });
    }
  }
}
```

### WebSocket over HTTP/2ã®è©³ç´°å®Ÿè£…

```javascript
// HTTP/2ä¸Šã§ã®WebSocketå®Ÿè£…
class WebSocketOverHTTP2 {
  constructor(url) {
    this.url = url;
    this.http2Features = {
      multiplexing: true,        // å¤šé‡åŒ–å¯¾å¿œ
      headerCompression: true,   // HPACKãƒ˜ãƒƒãƒ€ãƒ¼åœ§ç¸®
      serverPush: false,         // Server Pushéä½¿ç”¨
      binaryFraming: true        // ãƒã‚¤ãƒŠãƒªãƒ•ãƒ¬ãƒ¼ãƒŸãƒ³ã‚°
    };
    
    this.connectWithHTTP2Support();
  }
  
  connectWithHTTP2Support() {
    // HTTP/2å¯¾å¿œWebSocketæ¥ç¶š
    this.ws = new WebSocket(this.url);
    
    this.ws.onopen = () => {
      console.log('WebSocket over HTTP/2 connected');
      
      // HTTP/2æ¥ç¶šã®ç¢ºèª
      this.detectHTTP2Features();
    };
  }
  
  detectHTTP2Features() {
    // ãƒ–ãƒ©ã‚¦ã‚¶ã®HTTP/2ã‚µãƒãƒ¼ãƒˆæ¤œè¨¼
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').then(registration => {
        // Service WorkerçµŒç”±ã§HTTP/2æ©Ÿèƒ½ã‚’ç¢ºèª
        this.checkHTTP2Protocol(registration);
      });
    }
  }
  
  // HTTP/2ã®å¤šé‡åŒ–æ©Ÿèƒ½ã‚’æ´»ç”¨ã—ãŸè¤‡æ•°WebSocketç®¡ç†
  createMultiplexedConnections() {
    const connections = {};
    
    // åŒä¸€ãƒ‰ãƒ¡ã‚¤ãƒ³ã§è¤‡æ•°ã®WebSocketæ¥ç¶š
    // HTTP/2ã§ã¯åŒä¸€TCPæ¥ç¶šã‚’å†åˆ©ç”¨
    ['chat', 'notifications', 'updates'].forEach(channel => {
      connections[channel] = new WebSocket(
        `wss://example.com/${channel}`,
        [`${channel}-protocol`]
      );
      
      connections[channel].onopen = () => {
        console.log(`${channel} channel established over HTTP/2`);
      };
    });
    
    return connections;
  }
}
```

### HTTP/2ã¨WebSocketã®æ¯”è¼ƒè¡¨

<div class="overflow-x-auto mt-4">
<table class="min-w-full bg-white border border-gray-300">
<thead class="bg-gray-50">
<tr>
<th class="px-4 py-2 border-b text-left">ç‰¹å¾´</th>
<th class="px-4 py-2 border-b text-left">HTTP/2 Server Push</th>
<th class="px-4 py-2 border-b text-left">WebSocket over HTTP/2</th>
</tr>
</thead>
<tbody>
<tr class="bg-white">
<td class="px-4 py-2 border-b font-semibold">é€šä¿¡æ–¹å‘</td>
<td class="px-4 py-2 border-b text-red-600">ä¸€æ–¹å‘ã®ã¿</td>
<td class="px-4 py-2 border-b text-green-600">å®Œå…¨ãªåŒæ–¹å‘</td>
</tr>
<tr class="bg-gray-50">
<td class="px-4 py-2 border-b font-semibold">æ¥ç¶šãƒ¢ãƒ‡ãƒ«</td>
<td class="px-4 py-2 border-b text-orange-600">ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹</td>
<td class="px-4 py-2 border-b text-green-600">æŒç¶šçš„æ¥ç¶š</td>
</tr>
<tr class="bg-white">
<td class="px-4 py-2 border-b font-semibold">ãƒ–ãƒ©ã‚¦ã‚¶ã‚µãƒãƒ¼ãƒˆ</td>
<td class="px-4 py-2 border-b text-red-600">å»ƒæ­¢æ¸ˆã¿ï¼ˆChrome 106+ï¼‰</td>
<td class="px-4 py-2 border-b text-green-600">å…¨ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œ</td>
</tr>
<tr class="bg-gray-50">
<td class="px-4 py-2 border-b font-semibold">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§</td>
<td class="px-4 py-2 border-b text-orange-600">äºˆæ¸¬ãƒ™ãƒ¼ã‚¹</td>
<td class="px-4 py-2 border-b text-green-600">çœŸã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ </td>
</tr>
<tr class="bg-white">
<td class="px-4 py-2 border-b font-semibold">ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰</td>
<td class="px-4 py-2 border-b text-orange-600">HTTPãƒ˜ãƒƒãƒ€ãƒ¼æ¯å›</td>
<td class="px-4 py-2 border-b text-green-600">æœ€å°é™ã®ãƒ•ãƒ¬ãƒ¼ãƒ </td>
</tr>
<tr class="bg-gray-50">
<td class="px-4 py-2 border-b font-semibold">2025å¹´ã®æ¨å¥¨</td>
<td class="px-4 py-2 border-b text-red-600">ä½¿ç”¨éæ¨å¥¨</td>
<td class="px-4 py-2 border-b text-green-600">å¼·ãæ¨å¥¨</td>
</tr>
</tbody>
</table>
</div>

</Card>

<Card title="HTTP/2ç’°å¢ƒã§ã®WebSocketæœ€é©åŒ–" icon="âš¡" accentColor="green">

### HTTP/2ã®åˆ©ç‚¹ã‚’æ´»ç”¨ã—ãŸWebSocketå®Ÿè£…

```javascript
// HTTP/2ã®å¤šé‡åŒ–æ©Ÿèƒ½ã‚’æ´»ç”¨
class OptimizedWebSocketHTTP2 {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
    this.channels = new Map();
    this.setupMultiplexing();
  }
  
  setupMultiplexing() {
    // HTTP/2ã§ã¯åŒä¸€ãƒ‰ãƒ¡ã‚¤ãƒ³ã¸ã®è¤‡æ•°æ¥ç¶šãŒåŠ¹ç‡çš„
    const channelConfigs = [
      { name: 'realtime', path: '/ws/realtime', priority: 'high' },
      { name: 'notifications', path: '/ws/notifications', priority: 'medium' },
      { name: 'sync', path: '/ws/sync', priority: 'low' },
      { name: 'telemetry', path: '/ws/telemetry', priority: 'low' }
    ];
    
    channelConfigs.forEach(config => {
      this.createChannel(config);
    });
  }
  
  createChannel(config) {
    const ws = new WebSocket(
      `${this.baseUrl}${config.path}`,
      [`${config.name}-v1`]
    );
    
    ws.onopen = () => {
      console.log(`${config.name} channel ready (HTTP/2 multiplexed)`);
      
      // HTTP/2ã®å„ªå…ˆåº¦åˆ¶å¾¡ã‚’æ´»ç”¨
      this.configurePriority(ws, config.priority);
    };
    
    ws.onmessage = (event) => {
      this.routeMessage(config.name, event);
    };
    
    this.channels.set(config.name, {
      socket: ws,
      config: config,
      messageQueue: [],
      stats: { sent: 0, received: 0 }
    });
  }
  
  configurePriority(ws, priority) {
    // HTTP/2ã‚¹ãƒˆãƒªãƒ¼ãƒ å„ªå…ˆåº¦ã®å½±éŸ¿ã‚’è€ƒæ…®
    // å®Ÿéš›ã®å„ªå…ˆåº¦åˆ¶å¾¡ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã¨ã‚µãƒ¼ãƒãƒ¼ãŒå‡¦ç†
    const metadata = {
      priority: priority,
      timestamp: Date.now(),
      http2Multiplexed: true
    };
    
    ws.send(JSON.stringify({
      type: 'channel.config',
      metadata: metadata
    }));
  }
  
  // HTTP/2ã®ãƒ˜ãƒƒãƒ€ãƒ¼åœ§ç¸®åŠ¹æœã‚’æœ€å¤§åŒ–
  sendOptimizedMessage(channel, data) {
    const channelInfo = this.channels.get(channel);
    if (!channelInfo) return;
    
    // å…±é€šãƒ˜ãƒƒãƒ€ãƒ¼ã®æœ€é©åŒ–ï¼ˆHPACKåœ§ç¸®åŠ¹æœï¼‰
    const message = {
      v: '1.0',                    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³
      ts: Date.now(),              // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
      id: this.generateMessageId(), // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ID
      ch: channel,                 // ãƒãƒ£ãƒãƒ«å
      data: data                   // ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰
    };
    
    channelInfo.socket.send(JSON.stringify(message));
    channelInfo.stats.sent++;
  }
  
  // HTTP/2æ¥ç¶šã®çµ±è¨ˆæƒ…å ±
  getConnectionStats() {
    const stats = {
      totalChannels: this.channels.size,
      http2Features: {
        multiplexing: true,
        headerCompression: true,
        serverPush: false // WebSocketã«ã¯ä¸è¦
      },
      channelStats: {}
    };
    
    this.channels.forEach((info, name) => {
      stats.channelStats[name] = {
        readyState: info.socket.readyState,
        messagesSent: info.stats.sent,
        messagesReceived: info.stats.received,
        priority: info.config.priority
      };
    });
    
    return stats;
  }
}
```

### HTTP/2ç’°å¢ƒã§ã®æ³¨æ„ç‚¹

<div class="mt-4 p-4 bg-yellow-50 rounded-lg">
<h5 class="font-medium text-yellow-800">âš ï¸ HTTP/2ã§ã®WebSocketå®Ÿè£…æ³¨æ„ç‚¹</h5>
<ul class="text-sm text-yellow-700 mt-2 space-y-1">
<li>â€¢ **Server Pushéä½¿ç”¨**ï¼šWebSocketãŒã‚ã‚Œã°Server Pushã¯ä¸è¦</li>
<li>â€¢ **æ¥ç¶šå¤šé‡åŒ–**ï¼šåŒä¸€ãƒ‰ãƒ¡ã‚¤ãƒ³ã§ã®è¤‡æ•°WebSocketæ¥ç¶šã¯åŠ¹ç‡çš„</li>
<li>â€¢ **ãƒ˜ãƒƒãƒ€ãƒ¼åœ§ç¸®**ï¼šHPACKåœ§ç¸®ã®æ©æµã‚’å—ã‘ã‚‹ãŸã‚å…±é€šãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ´»ç”¨</li>
<li>â€¢ **å¾Œæ–¹äº’æ›æ€§**ï¼šHTTP/1.1ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ã®å®Ÿè£…ãŒé‡è¦</li>
</ul>
</div>

</Card>

</Section>

<Section title="HTTP/3ï¼ˆQUICï¼‰ã¨WebSocketï¼šæ¬¡ä¸–ä»£ã®åŒæ–¹å‘é€šä¿¡" icon="ğŸš€">

<Card title="HTTP/3ã§ã®WebSocket over QUIC" icon="ğŸ”®" accentColor="purple">

**HTTP/3**ã¯QUICãƒ—ãƒ­ãƒˆã‚³ãƒ«ä¸Šã§å‹•ä½œã—ã€WebSocketã«é©æ–°çš„ãªæ”¹è‰¯ã‚’ã‚‚ãŸã‚‰ã—ã¾ã™ã€‚

### QUICä¸Šã§ã®WebSocketå®Ÿè£…

```javascript
// HTTP/3 (QUIC)ä¸Šã®WebSocketå®Ÿè£…
class WebSocketOverQUIC {
  constructor(url, options = {}) {
    this.url = url;
    this.quicFeatures = {
      connectionMigration: true,    // æ¥ç¶šç§»è¡Œ
      zeroRTTReconnection: true,   // 0-RTTå†æ¥ç¶š
      builtInTLS: true,            // TLSçµ±åˆ
      multiplexing: true,          // ã‚¹ãƒˆãƒªãƒ¼ãƒ å¤šé‡åŒ–
      connectionLessHandshake: true // ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ¬ã‚¹
    };
    
    this.options = {
      enableQUIC: true,
      enable0RTT: options.enable0RTT !== false,
      enableConnectionMigration: options.enableConnectionMigration !== false,
      ...options
    };
    
    this.connectWithQUIC();
  }
  
  async connectWithQUIC() {
    try {
      // HTTP/3å¯¾å¿œã®ç¢ºèª
      if (!this.isHTTP3Supported()) {
        console.log('HTTP/3 not supported, falling back to HTTP/2');
        return this.fallbackToHTTP2();
      }
      
      // QUICæ¥ç¶šã®ç¢ºç«‹
      this.ws = new WebSocket(this.url, {
        protocols: ['websocket-over-quic-v1'],
        // HTTP/3å›ºæœ‰ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆå°†æ¥ã®å®Ÿè£…ï¼‰
        preferredVersion: 'h3',
        enableQUICFeatures: this.options.enableQUIC
      });
      
      this.setupQUICEventHandlers();
      
    } catch (error) {
      console.error('QUIC WebSocket connection failed:', error);
      this.fallbackToHTTP2();
    }
  }
  
  setupQUICEventHandlers() {
    this.ws.onopen = (event) => {
      console.log('WebSocket over QUIC connected');
      console.log('QUIC features active:', this.detectQUICFeatures());
      
      // 0-RTTãƒ‡ãƒ¼ã‚¿ã®é€ä¿¡ï¼ˆå†æ¥ç¶šæ™‚ï¼‰
      if (this.has0RTTData()) {
        this.send0RTTData();
      }
    };
    
    // QUICå›ºæœ‰ã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå°†æ¥ã®å®Ÿè£…ï¼‰
    this.ws.onconnectionmigration = (event) => {
      console.log('QUIC connection migrated:', event.newPath);
      this.handleConnectionMigration(event);
    };
    
    this.ws.onnetworkchange = (event) => {
      console.log('Network changed, QUIC adapting:', event);
      // QUICã®è‡ªå‹•ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é©å¿œ
    };
  }
  
  detectQUICFeatures() {
    // ç¾åœ¨åˆ©ç”¨å¯èƒ½ãªQUICæ©Ÿèƒ½ã®æ¤œå‡º
    return {
      version: this.ws.protocol || 'unknown',
      connectionMigration: this.ws.connectionMigrationEnabled || false,
      zeroRTT: this.ws.zeroRTTEnabled || false,
      congestionControl: this.ws.congestionControl || 'cubic'
    };
  }
  
  // 0-RTTå†æ¥ç¶šã®å®Ÿè£…
  enable0RTTReconnection() {
    // å‰å›ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ã‚’ä¿å­˜
    this.sessionTicket = {
      ticket: this.ws.sessionTicket,
      timestamp: Date.now(),
      serverParams: this.ws.serverTransportParams
    };
    
    localStorage.setItem('quic-session', JSON.stringify(this.sessionTicket));
  }
  
  send0RTTData() {
    const cachedData = this.get0RTTCachedData();
    if (cachedData && this.ws.readyState === WebSocket.CONNECTING) {
      // 0-RTTã§ã®å³åº§ã®ãƒ‡ãƒ¼ã‚¿é€ä¿¡
      this.ws.send(JSON.stringify({
        type: '0rtt-data',
        cached: true,
        data: cachedData
      }));
    }
  }
  
  // æ¥ç¶šç§»è¡Œã®å‡¦ç†
  handleConnectionMigration(event) {
    console.log('Migrating connection from', event.oldPath, 'to', event.newPath);
    
    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ä¿æŒ
    this.preserveApplicationState();
    
    // æ–°ã—ã„ãƒ‘ã‚¹ã§ã®æ¥ç¶šç¢ºèª
    this.validateNewConnection();
  }
  
  isHTTP3Supported() {
    // HTTP/3ã‚µãƒãƒ¼ãƒˆã®æ¤œå‡º
    if (typeof window === 'undefined') return false;
    
    // ç¾åœ¨ã®æ¤œå‡ºæ–¹æ³•ï¼ˆ2025å¹´æ™‚ç‚¹ï¼‰
    return 'serviceWorker' in navigator && 
           'fetch' in window &&
           window.chrome && 
           window.chrome.loadTimes; // Chrome/Edgeå›ºæœ‰
  }
}
```

### QUICãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®åˆ©ç‚¹æ´»ç”¨

```javascript
// QUICå›ºæœ‰ã®æ©Ÿèƒ½ã‚’æ´»ç”¨ã—ãŸWebSocketç®¡ç†
class QUICOptimizedWebSocket {
  constructor(url) {
    this.url = url;
    this.quicStats = {
      connectionMigrations: 0,
      zeroRTTAttempts: 0,
      zeroRTTSuccesses: 0,
      packetLoss: 0,
      rttMeasurements: []
    };
    
    this.setupQUICOptimizations();
  }
  
  setupQUICOptimizations() {
    // QUICå¤šé‡åŒ–ã‚¹ãƒˆãƒªãƒ¼ãƒ æ´»ç”¨
    this.streams = {
      highPriority: this.createPriorityStream('high'),
      normalPriority: this.createPriorityStream('normal'),
      lowPriority: this.createPriorityStream('low'),
      background: this.createPriorityStream('background')
    };
  }
  
  createPriorityStream(priority) {
    const ws = new WebSocket(this.url, [`stream-${priority}-v1`]);
    
    ws.onopen = () => {
      console.log(`${priority} priority stream established`);
      
      // QUICå›ºæœ‰ã®è¨­å®š
      this.configureQUICStream(ws, priority);
    };
    
    return ws;
  }
  
  configureQUICStream(ws, priority) {
    // QUICã‚¹ãƒˆãƒªãƒ¼ãƒ å„ªå…ˆåº¦è¨­å®šï¼ˆå°†æ¥ã®å®Ÿè£…ï¼‰
    const priorityConfig = {
      urgency: this.getPriorityUrgency(priority),
      incremental: priority !== 'high',
      weight: this.getPriorityWeight(priority)
    };
    
    ws.send(JSON.stringify({
      type: 'stream.config',
      priority: priorityConfig
    }));
  }
  
  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¤‰æ›´ã¸ã®é©å¿œ
  handleNetworkChange() {
    // QUICã®æ¥ç¶šç§»è¡Œæ©Ÿèƒ½ã‚’æ´»ç”¨
    console.log('Network change detected, QUIC will handle migration');
    
    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«ã§ã®æº–å‚™
    this.prepareForMigration();
  }
  
  prepareForMigration() {
    // æœªé€ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    this.backupPendingMessages();
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ä¿å­˜
    this.saveSessionState();
    
    // ç§»è¡Œå®Œäº†å¾Œã®å¾©å…ƒæº–å‚™
    this.prepareMigrationRecovery();
  }
  
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
  measureQUICPerformance() {
    return {
      rtt: this.measureRTT(),
      throughput: this.measureThroughput(),
      packetLoss: this.quicStats.packetLoss,
      connectionMigrations: this.quicStats.connectionMigrations,
      zeroRTTSuccessRate: this.quicStats.zeroRTTSuccesses / this.quicStats.zeroRTTAttempts
    };
  }
}
```

</Card>

<Card title="WebTransportï¼šHTTP/3ã«ã‚ˆã‚‹æ–°ã—ã„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ" icon="ğŸŒ" accentColor="blue">

**WebTransport**ã¯ã€HTTP/3ä¸Šã§ã®æ–°ã—ã„åŒæ–¹å‘é€šä¿¡APIã§ã€WebSocketã®ä»£æ›¿ã¨ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

### WebTransportã®å®Ÿè£…ä¾‹

```javascript
// WebTransportå®Ÿè£…ï¼ˆå®Ÿé¨“çš„æ©Ÿèƒ½ï¼‰
class WebTransportConnection {
  constructor(url) {
    this.url = url;
    this.transport = null;
    this.streams = new Map();
    this.datagrams = [];
    
    this.connectWebTransport();
  }
  
  async connectWebTransport() {
    try {
      // WebTransportã‚µãƒãƒ¼ãƒˆã®ç¢ºèª
      if (!('WebTransport' in window)) {
        throw new Error('WebTransport not supported');
      }
      
      // WebTransportæ¥ç¶šã®ç¢ºç«‹
      this.transport = new WebTransport(this.url);
      
      await this.transport.ready;
      console.log('WebTransport connection established');
      
      this.setupWebTransportHandlers();
      
    } catch (error) {
      console.error('WebTransport connection failed:', error);
      console.log('Falling back to WebSocket');
      this.fallbackToWebSocket();
    }
  }
  
  setupWebTransportHandlers() {
    // ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†
    this.handleIncomingStreams();
    
    // ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ å‡¦ç†
    this.handleIncomingDatagrams();
    
    // æ¥ç¶šçŠ¶æ…‹ç›£è¦–
    this.transport.closed.then(() => {
      console.log('WebTransport connection closed');
    }).catch(error => {
      console.error('WebTransport connection error:', error);
    });
  }
  
  async handleIncomingStreams() {
    const reader = this.transport.incomingBidirectionalStreams.getReader();
    
    while (true) {
      try {
        const { value: stream, done } = await reader.read();
        if (done) break;
        
        console.log('New bidirectional stream received');
        this.processIncomingStream(stream);
        
      } catch (error) {
        console.error('Stream reading error:', error);
        break;
      }
    }
  }
  
  async handleIncomingDatagrams() {
    const reader = this.transport.datagrams.readable.getReader();
    
    while (true) {
      try {
        const { value: datagram, done } = await reader.read();
        if (done) break;
        
        console.log('Datagram received:', datagram);
        this.processDatagram(datagram);
        
      } catch (error) {
        console.error('Datagram reading error:', error);
        break;
      }
    }
  }
  
  // ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹é€šä¿¡ï¼ˆä¿¡é ¼æ€§ã‚ã‚Šï¼‰
  async sendStreamMessage(data) {
    try {
      const stream = await this.transport.createBidirectionalStream();
      const writer = stream.writable.getWriter();
      
      const encoder = new TextEncoder();
      const encoded = encoder.encode(JSON.stringify(data));
      
      await writer.write(encoded);
      await writer.close();
      
      console.log('Stream message sent');
      
    } catch (error) {
      console.error('Stream sending error:', error);
    }
  }
  
  // ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ ãƒ™ãƒ¼ã‚¹é€šä¿¡ï¼ˆä½é…å»¶ï¼‰
  async sendDatagramMessage(data) {
    try {
      const writer = this.transport.datagrams.writable.getWriter();
      
      const encoder = new TextEncoder();
      const encoded = encoder.encode(JSON.stringify(data));
      
      await writer.write(encoded);
      console.log('Datagram sent');
      
    } catch (error) {
      console.error('Datagram sending error:', error);
    }
  }
  
  // WebSocketãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  fallbackToWebSocket() {
    console.log('Initializing WebSocket fallback');
    this.websocket = new WebSocket(this.url.replace('https://', 'wss://'));
    
    this.websocket.onopen = () => {
      console.log('WebSocket fallback connected');
    };
    
    this.websocket.onmessage = (event) => {
      this.processWebSocketMessage(event.data);
    };
  }
}
```

### WebTransportã¨WebSocketã®æ¯”è¼ƒ

<div class="overflow-x-auto mt-4">
<table class="min-w-full bg-white border border-gray-300">
<thead class="bg-gray-50">
<tr>
<th class="px-4 py-2 border-b text-left">ç‰¹å¾´</th>
<th class="px-4 py-2 border-b text-left">WebSocket</th>
<th class="px-4 py-2 border-b text-left">WebTransport</th>
</tr>
</thead>
<tbody>
<tr class="bg-white">
<td class="px-4 py-2 border-b font-semibold">åŸºç›¤ãƒ—ãƒ­ãƒˆã‚³ãƒ«</td>
<td class="px-4 py-2 border-b">TCPä¸Šã®HTTP/1.1</td>
<td class="px-4 py-2 border-b">QUICä¸Šã®HTTP/3</td>
</tr>
<tr class="bg-gray-50">
<td class="px-4 py-2 border-b font-semibold">ãƒ‡ãƒ¼ã‚¿é…ä¿¡</td>
<td class="px-4 py-2 border-b">é †åºä¿è¨¼ã‚ã‚Š</td>
<td class="px-4 py-2 border-b">ã‚¹ãƒˆãƒªãƒ¼ãƒ /ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ é¸æŠå¯</td>
</tr>
<tr class="bg-white">
<td class="px-4 py-2 border-b font-semibold">æ¥ç¶šç¢ºç«‹</td>
<td class="px-4 py-2 border-b">TCP 3-way handshake</td>
<td class="px-4 py-2 border-b">0-RTTå¯èƒ½</td>
</tr>
<tr class="bg-gray-50">
<td class="px-4 py-2 border-b font-semibold">å¤šé‡åŒ–</td>
<td class="px-4 py-2 border-b">å˜ä¸€ã‚¹ãƒˆãƒªãƒ¼ãƒ </td>
<td class="px-4 py-2 border-b">è¤‡æ•°ã‚¹ãƒˆãƒªãƒ¼ãƒ ä¸¦åˆ—</td>
</tr>
<tr class="bg-white">
<td class="px-4 py-2 border-b font-semibold">ãƒ–ãƒ©ã‚¦ã‚¶ã‚µãƒãƒ¼ãƒˆ</td>
<td class="px-4 py-2 border-b text-green-600">å…¨ãƒ–ãƒ©ã‚¦ã‚¶</td>
<td class="px-4 py-2 border-b text-orange-600">Chrome/Edgeï¼ˆå®Ÿé¨“çš„ï¼‰</td>
</tr>
<tr class="bg-gray-50">
<td class="px-4 py-2 border-b font-semibold">2025å¹´æ¨å¥¨</td>
<td class="px-4 py-2 border-b text-green-600">ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ä½¿ç”¨</td>
<td class="px-4 py-2 border-b text-orange-600">å®Ÿé¨“ãƒ»è©•ä¾¡æ®µéš</td>
</tr>
</tbody>
</table>
</div>

</Card>

</Section>

<Section title="2025å¹´ç¾åœ¨ã®æ¨å¥¨å®Ÿè£…æˆ¦ç•¥" icon="ğŸ¯">

<Card title="ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§ã®æœ€é©é¸æŠ" icon="âš™ï¸" accentColor="green">

### 2025å¹´ã®æ¨å¥¨ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```javascript
// 2025å¹´æ¨å¥¨ï¼šãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–WebSocketå®Ÿè£…
class ProgressiveWebSocketStrategy {
  constructor(url, options = {}) {
    this.url = url;
    this.options = options;
    
    // ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚µãƒãƒ¼ãƒˆã®å„ªå…ˆé †ä½
    this.protocolPriority = [
      'websocket-over-http3',  // å®Ÿé¨“çš„ï¼šHTTP/3å¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶
      'websocket-over-http2',  // æ¨å¥¨ï¼šHTTP/2ç’°å¢ƒ
      'websocket-over-http1.1' // åŸºç›¤ï¼šå…¨ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œ
    ];
    
    this.implementProgressiveConnection();
  }
  
  async implementProgressiveConnection() {
    // æ©Ÿèƒ½æ¤œå‡ºã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«é¸æŠ
    const supportedProtocol = await this.detectBestProtocol();
    
    switch (supportedProtocol) {
      case 'http3':
        await this.connectWithHTTP3();
        break;
      case 'http2':
        await this.connectWithHTTP2();
        break;
      default:
        await this.connectWithHTTP11();
    }
  }
  
  async detectBestProtocol() {
    // HTTP/3ã‚µãƒãƒ¼ãƒˆæ¤œå‡º
    if (await this.isHTTP3Available()) {
      console.log('Using HTTP/3 for WebSocket');
      return 'http3';
    }
    
    // HTTP/2ã‚µãƒãƒ¼ãƒˆæ¤œå‡º
    if (await this.isHTTP2Available()) {
      console.log('Using HTTP/2 for WebSocket');
      return 'http2';
    }
    
    console.log('Using HTTP/1.1 for WebSocket');
    return 'http1.1';
  }
  
  async connectWithHTTP11() {
    // HTTP/1.1åŸºç›¤å®Ÿè£…ï¼ˆæœ€ã‚‚å®‰å®šï¼‰
    this.ws = new WebSocket(this.url, this.options.protocols);
    
    this.ws.onopen = () => {
      console.log('HTTP/1.1 WebSocket established');
      this.recordProtocolUsage('http1.1');
    };
    
    return this.setupStandardWebSocket();
  }
  
  async connectWithHTTP2() {
    // HTTP/2æœ€é©åŒ–å®Ÿè£…
    this.ws = new WebSocket(this.url, this.options.protocols);
    
    // HTTP/2ã®å¤šé‡åŒ–ã‚’æ´»ç”¨ã—ãŸè¿½åŠ æ¥ç¶š
    this.additionalChannels = this.setupMultiplexedChannels();
    
    this.ws.onopen = () => {
      console.log('HTTP/2 WebSocket with multiplexing');
      this.recordProtocolUsage('http2');
    };
    
    return this.setupOptimizedWebSocket();
  }
  
  async connectWithHTTP3() {
    // HTTP/3å®Ÿé¨“çš„å®Ÿè£…
    try {
      // WebTransportã®è©¦è¡Œ
      if ('WebTransport' in window) {
        this.transport = new WebTransport(this.url);
        await this.transport.ready;
        console.log('WebTransport over HTTP/3 established');
        this.recordProtocolUsage('webtransport');
        return this.setupWebTransport();
      }
      
      // å¾“æ¥WebSocket over HTTP/3
      this.ws = new WebSocket(this.url, this.options.protocols);
      this.recordProtocolUsage('websocket-http3');
      return this.setupQUICWebSocket();
      
    } catch (error) {
      console.log('HTTP/3 failed, falling back to HTTP/2');
      return this.connectWithHTTP2();
    }
  }
  
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã¨è‡ªå‹•æœ€é©åŒ–
  startPerformanceMonitoring() {
    this.performanceMonitor = {
      latency: [],
      throughput: [],
      reliability: { connected: 0, disconnected: 0 }
    };
    
    setInterval(() => {
      this.measurePerformance();
      this.optimizeConnection();
    }, 30000);
  }
  
  measurePerformance() {
    const metrics = {
      timestamp: Date.now(),
      rtt: this.measureRoundTripTime(),
      throughput: this.calculateThroughput(),
      protocol: this.currentProtocol
    };
    
    this.performanceMonitor.latency.push(metrics.rtt);
    this.performanceMonitor.throughput.push(metrics.throughput);
    
    return metrics;
  }
  
  // ãƒ—ãƒ­ãƒˆã‚³ãƒ«åˆ©ç”¨çµ±è¨ˆã®åé›†
  recordProtocolUsage(protocol) {
    this.currentProtocol = protocol;
    
    const usage = JSON.parse(localStorage.getItem('websocket-protocol-usage') || '{}');
    usage[protocol] = (usage[protocol] || 0) + 1;
    usage.lastUsed = protocol;
    usage.timestamp = Date.now();
    
    localStorage.setItem('websocket-protocol-usage', JSON.stringify(usage));
  }
}
```

### ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºç’°å¢ƒã§ã®å®Ÿè£…ã‚¬ã‚¤ãƒ‰

```javascript
// ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰WebSocketå®Ÿè£…
class EnterpriseWebSocketManager {
  constructor(config) {
    this.config = {
      primaryUrl: config.primaryUrl,
      fallbackUrls: config.fallbackUrls || [],
      healthCheckInterval: config.healthCheckInterval || 30000,
      maxReconnectAttempts: config.maxReconnectAttempts || 10,
      loadBalancing: config.loadBalancing || 'round-robin',
      monitoring: config.monitoring || {},
      ...config
    };
    
    this.connectionPool = new Map();
    this.healthStatus = new Map();
    this.loadBalancer = new LoadBalancer(this.config.loadBalancing);
    
    this.initializeEnterpriseFeatures();
  }
  
  initializeEnterpriseFeatures() {
    // è¤‡æ•°ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šãƒ—ãƒ¼ãƒ«
    this.setupConnectionPool();
    
    // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 
    this.startHealthMonitoring();
    
    // ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°
    this.configureLoadBalancing();
    
    // ç›£è¦–ãƒ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 
    this.setupMonitoring();
  }
  
  setupConnectionPool() {
    const urls = [this.config.primaryUrl, ...this.config.fallbackUrls];
    
    urls.forEach((url, index) => {
      const connection = new ProductionWebSocket(url, {
        id: `connection-${index}`,
        isPrimary: index === 0,
        protocols: this.config.protocols,
        autoReconnect: true
      });
      
      this.connectionPool.set(url, connection);
      this.healthStatus.set(url, { status: 'connecting', lastCheck: Date.now() });
    });
  }
  
  startHealthMonitoring() {
    this.healthCheckTimer = setInterval(() => {
      this.performHealthChecks();
    }, this.config.healthCheckInterval);
  }
  
  async performHealthChecks() {
    const healthPromises = Array.from(this.connectionPool.entries()).map(
      ([url, connection]) => this.checkConnectionHealth(url, connection)
    );
    
    const results = await Promise.allSettled(healthPromises);
    
    results.forEach((result, index) => {
      const url = Array.from(this.connectionPool.keys())[index];
      if (result.status === 'fulfilled') {
        this.healthStatus.set(url, result.value);
      } else {
        this.healthStatus.set(url, { 
          status: 'unhealthy', 
          error: result.reason,
          lastCheck: Date.now() 
        });
      }
    });
    
    // ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«åŸºã¥ãè‡ªå‹•ãƒ•ã‚§ã‚¤ãƒ«ã‚ªãƒ¼ãƒãƒ¼
    this.handleHealthResults();
  }
  
  // ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºç›£è¦–æ©Ÿèƒ½
  setupMonitoring() {
    this.metrics = {
      totalConnections: 0,
      activeConnections: 0,
      messagesSent: 0,
      messagesReceived: 0,
      errors: 0,
      latencyHistory: [],
      uptimeStart: Date.now()
    };
    
    // ç›£è¦–ãƒ‡ãƒ¼ã‚¿ã®å®šæœŸé€ä¿¡
    if (this.config.monitoring.endpoint) {
      setInterval(() => {
        this.sendMonitoringData();
      }, this.config.monitoring.interval || 60000);
    }
  }
  
  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–
  setupSecurityFeatures() {
    return {
      authentication: this.setupAuthentication(),
      authorization: this.setupAuthorization(),
      rateLimiting: this.setupRateLimiting(),
      inputValidation: this.setupInputValidation(),
      auditLogging: this.setupAuditLogging()
    };
  }
  
  // ä½¿ç”¨çµ±è¨ˆã¨ãƒ¬ãƒãƒ¼ãƒˆ
  generateUsageReport() {
    const report = {
      timestamp: new Date().toISOString(),
      protocol: {
        http11: this.getProtocolUsage('http1.1'),
        http2: this.getProtocolUsage('http2'),
        http3: this.getProtocolUsage('http3')
      },
      performance: {
        averageLatency: this.calculateAverageLatency(),
        throughput: this.calculateThroughput(),
        reliability: this.calculateReliability()
      },
      errors: this.getErrorSummary(),
      recommendations: this.generateRecommendations()
    };
    
    return report;
  }
}
```

</Card>

<Card title="2025å¹´ã®å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ" icon="âœ…" accentColor="indigo">

### ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³å¯¾å¿œãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

**åŸºç›¤æŠ€è¡“**
- [ ] **HTTP/1.1 WebSocket**ï¼šç¢ºå®ŸãªåŸºç›¤å®Ÿè£…
- [ ] **ãƒ—ãƒ­ãƒˆã‚³ãƒ«é¸æŠ**ï¼šç’°å¢ƒã«å¿œã˜ãŸæœ€é©åŒ–
- [ ] **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½**ï¼šHTTP/3 â†’ HTTP/2 â†’ HTTP/1.1
- [ ] **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾å¿œ**ï¼šwss://ã€èªè¨¼ã€èªå¯

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**
- [ ] **HTTP/2å¤šé‡åŒ–**ï¼šè¤‡æ•°ãƒãƒ£ãƒãƒ«æ´»ç”¨
- [ ] **åœ§ç¸®æ©Ÿèƒ½**ï¼špermessage-deflateç­‰ã®æ´»ç”¨
- [ ] **æ¥ç¶šãƒ—ãƒ¼ãƒ«**ï¼šè¤‡æ•°ã‚µãƒ¼ãƒãƒ¼å¯¾å¿œ
- [ ] **ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°**ï¼šè² è·åˆ†æ•£å®Ÿè£…

**ä¿¡é ¼æ€§ãƒ»é‹ç”¨**
- [ ] **è‡ªå‹•å†æ¥ç¶š**ï¼šãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³å¯¾å¿œ
- [ ] **ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯**ï¼šæ¥ç¶šçŠ¶æ…‹ç›£è¦–
- [ ] **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**ï¼šåŒ…æ‹¬çš„ãªä¾‹å¤–å‡¦ç†
- [ ] **ç›£è¦–ãƒ»ãƒ­ã‚°**ï¼šé‹ç”¨ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 

**å°†æ¥å¯¾å¿œ**
- [ ] **HTTP/3æº–å‚™**ï¼šå®Ÿé¨“çš„å®Ÿè£…ã®è©•ä¾¡
- [ ] **WebTransportæ¤œè¨¼**ï¼šæ¬¡ä¸–ä»£æŠ€è¡“ã®èª¿æŸ»
- [ ] **ãƒ—ãƒ­ãƒˆã‚³ãƒ«çµ±è¨ˆ**ï¼šä½¿ç”¨çŠ¶æ³ã®åˆ†æ
- [ ] **æ®µéšçš„ç§»è¡Œè¨ˆç”»**ï¼šæ–°æŠ€è¡“ã¸ã®ç§»è¡Œæˆ¦ç•¥

### 2025å¹´ã®æ¨å¥¨æˆ¦ç•¥ã¾ã¨ã‚

**ç¾åœ¨ï¼ˆ2025å¹´ï¼‰**
1. **HTTP/1.1 WebSocket**ã‚’åŸºç›¤ã¨ã—ãŸç¢ºå®Ÿãªå®Ÿè£…
2. **HTTP/2ç’°å¢ƒ**ã§ã®å¤šé‡åŒ–æ©Ÿèƒ½æ´»ç”¨
3. **ãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–å¼·åŒ–**ã«ã‚ˆã‚‹æ®µéšçš„æœ€é©åŒ–

**çŸ­æœŸï¼ˆ2025-2026å¹´ï¼‰**
1. **HTTP/3å¯¾å¿œ**ã®å®Ÿé¨“çš„å°å…¥
2. **WebTransport**ã®è©•ä¾¡ãƒ»æ¤œè¨¼
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š**ã«åŸºã¥ãæœ€é©åŒ–

**ä¸­é•·æœŸï¼ˆ2026å¹´ä»¥é™ï¼‰**
1. **WebTransport**ã®æœ¬æ ¼æ¡ç”¨æ¤œè¨
2. **QUIC**ã«ã‚ˆã‚‹ä½é…å»¶é€šä¿¡ã®æ´»ç”¨
3. **æ¬¡ä¸–ä»£ãƒ—ãƒ­ãƒˆã‚³ãƒ«**ã¸ã®ç§»è¡Œè¨ˆç”»

</Card>

</Section>

<Section title="å­¦ç¿’æˆæœã®ç¢ºèª" icon="ğŸ“Š">

<Card title="ç¿’å¾—ã—ãŸçŸ¥è­˜ã®ç·æ‹¬" icon="ğŸ¯" accentColor="indigo">

<div class="grid md:grid-cols-2 gap-6">

<div>
<h4 class="font-semibold text-indigo-800 mb-3">ğŸ”¬ æŠ€è¡“çš„ç†è§£</h4>
<ul class="space-y-2 text-sm text-indigo-700">
<li>âœ“ HTTP/1.1ã§ã®WebSocket Upgradeãƒ¡ã‚«ãƒ‹ã‚ºãƒ </li>
<li>âœ“ HTTP/2 Server Pushã¨WebSocketã®æŠ€è¡“çš„å·®ç•°</li>
<li>âœ“ HTTP/3ï¼ˆQUICï¼‰ä¸Šã§ã®WebSocketå‹•ä½œåŸç†</li>
<li>âœ“ WebTransportã«ã‚ˆã‚‹æ¬¡ä¸–ä»£åŒæ–¹å‘é€šä¿¡</li>
<li>âœ“ å„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®æ€§èƒ½ç‰¹æ€§ã¨é©ç”¨å ´é¢</li>
</ul>
</div>

<div>
<h4 class="font-semibold text-indigo-800 mb-3">ğŸ› ï¸ å®Ÿè£…èƒ½åŠ›</h4>
<ul class="space-y-2 text-sm text-indigo-700">
<li>âœ“ ãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–WebSocketå®Ÿè£…</li>
<li>âœ“ HTTP/2å¤šé‡åŒ–æ©Ÿèƒ½ã®æ´»ç”¨</li>
<li>âœ“ ãƒ—ãƒ­ãƒˆã‚³ãƒ«æ¤œå‡ºã¨è‡ªå‹•é¸æŠ</li>
<li>âœ“ ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰é‹ç”¨è¨­è¨ˆ</li>
<li>âœ“ å°†æ¥æŠ€è¡“ã¸ã®ç§»è¡Œæˆ¦ç•¥ç­–å®š</li>
</ul>
</div>

</div>

#### å®Ÿè·µçš„ãªä¾¡å€¤

**ç¾åœ¨ã®é–‹ç™ºã«ãŠã‘ã‚‹ä¾¡å€¤**
- æœ€é©ãªWebSocketãƒ—ãƒ­ãƒˆã‚³ãƒ«é¸æŠã«ã‚ˆã‚‹æ€§èƒ½å‘ä¸Š
- HTTP/2ç’°å¢ƒã§ã®åŠ¹ç‡çš„ãªå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³
- ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºç’°å¢ƒã§ã®ä¿¡é ¼æ€§ç¢ºä¿

**å°†æ¥ã¸ã®æº–å‚™ä¾¡å€¤**
- HTTP/3/QUICæŠ€è¡“ã¸ã®å††æ»‘ãªç§»è¡Œæº–å‚™
- WebTransportç­‰æ–°æŠ€è¡“ã®é©åˆ‡ãªè©•ä¾¡èƒ½åŠ›
- æŠ€è¡“é€²åŒ–ã«å¯¾å¿œã§ãã‚‹æŸ”è»Ÿãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

</Card>

</Section>

</LessonLayout>