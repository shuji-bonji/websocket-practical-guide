---
title: 'ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰çµ±åˆã‚·ã‚¹ãƒ†ãƒ è©³ç´°'
description: 'ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã€API Gatewayã€åˆ†æ•£ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®WebSocketçµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³'
---

<script>
  import Mermaid from '$lib/components/Mermaid.svelte';
</script>

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

# ğŸ”§ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰çµ±åˆã‚·ã‚¹ãƒ†ãƒ è©³ç´°

## 1. ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### WebSocket Gatewayçµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³

</div>
</div>

<Mermaid chart={`
graph TB
    subgraph "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰"
        WEB[ğŸ’» Webã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] --> GATE[ğŸŒ API Gateway]
        MOBILE[ğŸ“± ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒª] --> GATE
        DESKTOP[ğŸ–¥ï¸ ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã‚¢ãƒ—ãƒª] --> GATE
    end
    
    subgraph "WebSocketå±¤"
        GATE --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> BROKER[ğŸ“¡ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼]
        BROKER --> ROUTER[ğŸ”„ ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³]
    end
    
    subgraph "ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ç¾¤"
        ROUTER --> USER[ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹]
        ROUTER --> ORDER[ğŸ“¦ æ³¨æ–‡ã‚µãƒ¼ãƒ“ã‚¹]
        ROUTER --> PAYMENT[ğŸ’³ æ±ºæ¸ˆã‚µãƒ¼ãƒ“ã‚¹]
        ROUTER --> INVENTORY[ğŸ“Š åœ¨åº«ã‚µãƒ¼ãƒ“ã‚¹]
        ROUTER --> NOTIFY[ğŸ”” é€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹]
    end
    
    subgraph "ãƒ‡ãƒ¼ã‚¿å±¤"
        USER --> USERDB[ğŸ’¾ ãƒ¦ãƒ¼ã‚¶ãƒ¼DB]
        ORDER --> ORDERDB[ğŸ’¾ æ³¨æ–‡DB]
        PAYMENT --> PAYMENTDB[ğŸ’¾ æ±ºæ¸ˆDB]
        INVENTORY --> INVENTORYDB[ğŸ’¾ åœ¨åº«DB]
    end
    
    subgraph "å¤–éƒ¨é€£æº"
        PAYMENT --> STRIPE[ğŸ’³ Stripe API]
        NOTIFY --> PUSH[ğŸ“² ãƒ—ãƒƒã‚·ãƒ¥ã‚µãƒ¼ãƒ“ã‚¹]
        INVENTORY --> ERP[ğŸ’¼ ERPã‚·ã‚¹ãƒ†ãƒ ]
    end
    
    style GATE fill:#f3e5f5
    style WS fill:#e8f5e8
    style BROKER fill:#fff3e0
    style ROUTER fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant C as ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    participant G as API Gateway
    participant WS as WebSocketã‚µãƒ¼ãƒãƒ¼
    participant B as ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼
    participant O as æ³¨æ–‡ã‚µãƒ¼ãƒ“ã‚¹
    participant I as åœ¨åº«ã‚µãƒ¼ãƒ“ã‚¹
    participant N as é€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹

    C->>G: æ³¨æ–‡ä½œæˆè¦æ±‚
    G->>O: æ³¨æ–‡å‡¦ç†
    O->>B: OrderCreated ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
    
    par ä¸¦åˆ—å‡¦ç†
        B->>I: åœ¨åº«ç¢ºèªãƒ»æ¸›å°‘
        B->>N: æ³¨æ–‡ç¢ºèªé€šçŸ¥æº–å‚™
    end
    
    I->>B: InventoryUpdated ã‚¤ãƒ™ãƒ³ãƒˆ
    N->>B: NotificationReady ã‚¤ãƒ™ãƒ³ãƒˆ
    
    B->>WS: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°é…ä¿¡
    WS->>C: æ³¨æ–‡çŠ¶æ³ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥
    
    alt åœ¨åº«ä¸è¶³ã®å ´åˆ
        I->>B: OutOfStock ã‚¤ãƒ™ãƒ³ãƒˆ
        B->>O: æ³¨æ–‡ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†
        O->>B: OrderCancelled ã‚¤ãƒ™ãƒ³ãƒˆ
        B->>WS: ã‚­ãƒ£ãƒ³ã‚»ãƒ«é€šçŸ¥é…ä¿¡
    end
    
    Note over C,N: ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã«ã‚ˆã‚‹ç–çµåˆè¨­è¨ˆ
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 2. API Gatewayçµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³

### WebSocketãƒ»RESTãƒ»GraphQLçµ±åˆ

</div>
</div>

<Mermaid chart={`
graph TD
    subgraph "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå±¤"
        SPA[ğŸ“± SPAã‚¢ãƒ—ãƒª] --> GATE[ğŸŒ API Gateway]
        MOBILE[ğŸ“± Native App] --> GATE
        IOT[ğŸŒ IoTãƒ‡ãƒã‚¤ã‚¹] --> GATE
    end
    
    subgraph "ãƒ—ãƒ­ãƒˆã‚³ãƒ«å¤‰æ›"
        GATE --> REST[ğŸ”— REST API]
        GATE --> WS[WebSocket]
        GATE --> GQL[ğŸ“Š GraphQL]
        GATE --> GRPC[âš¡ gRPC]
    end
    
    subgraph "èªè¨¼ãƒ»èªå¯"
        REST --> AUTH[ğŸ” èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹]
        WS --> AUTH
        GQL --> AUTH
        AUTH --> JWT[ğŸ« JWTæ¤œè¨¼]
        JWT --> RBAC[ğŸ›¡ï¸ RBACåˆ¶å¾¡]
    end
    
    subgraph "ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°"
        REST --> LB1[âš–ï¸ REST LB]
        WS --> LB2[âš–ï¸ WebSocket LB]
        GQL --> LB3[âš–ï¸ GraphQL LB]
    end
    
    subgraph "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹"
        LB1 --> SERVICE1[ğŸ”§ ã‚µãƒ¼ãƒ“ã‚¹ç¾¤A]
        LB2 --> SERVICE2[ğŸ”§ ã‚µãƒ¼ãƒ“ã‚¹ç¾¤B]
        LB3 --> SERVICE3[ğŸ”§ ã‚µãƒ¼ãƒ“ã‚¹ç¾¤C]
    end
    
    subgraph "ç›£è¦–ãƒ»ãƒ­ã‚°"
        GATE --> METRICS[ğŸ“Š ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†]
        GATE --> LOGS[ğŸ“‹ ãƒ­ã‚°é›†ç´„]
        GATE --> TRACE[ğŸ” åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°]
    end
    
    style GATE fill:#f3e5f5
    style AUTH fill:#e8f5e8
    style LB2 fill:#fff3e0
    style METRICS fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ»ã‚¹ãƒ­ãƒƒãƒˆãƒªãƒ³ã‚°

</div>
</div>

<Mermaid chart={`
graph LR
    subgraph "ãƒªã‚¯ã‚¨ã‚¹ãƒˆæµå…¥"
        CLIENT[ğŸ‘¤ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] --> RATE[ğŸ“Š ãƒ¬ãƒ¼ãƒˆåˆ¶é™]
        RATE --> BUCKET[ğŸª£ Token Bucket]
        BUCKET --> WINDOW[â° Sliding Window]
    end
    
    subgraph "åˆ¶é™ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ "
        WINDOW --> FIXED[ğŸ“ Fixed Window]
        WINDOW --> SLIDING[ğŸ”„ Sliding Log]
        WINDOW --> ADAPTIVE[ğŸ¯ é©å¿œåˆ¶å¾¡]
    end
    
    subgraph "åˆ¶é™åˆ¤å®š"
        ADAPTIVE --> ALLOW[âœ… è¨±å¯]
        ADAPTIVE --> THROTTLE[â³ ã‚¹ãƒ­ãƒƒãƒˆãƒªãƒ³ã‚°]
        ADAPTIVE --> REJECT[âŒ æ‹’å¦]
    end
    
    subgraph "WebSocketé©ç”¨"
        ALLOW --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        THROTTLE --> DELAY[â±ï¸ é…å»¶é…ä¿¡]
        REJECT --> ERROR[ğŸš« ã‚¨ãƒ©ãƒ¼é€šçŸ¥]
    end
    
    subgraph "å‹•çš„èª¿æ•´"
        WS --> MONITOR[ğŸ“Š ç›£è¦–]
        MONITOR --> FEEDBACK[ğŸ”„ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯]
        FEEDBACK --> ADAPTIVE
    end
    
    style RATE fill:#f3e5f5
    style ADAPTIVE fill:#e8f5e8
    style WS fill:#fff3e0
    style MONITOR fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³

### CQRS + Event Sourcing

</div>
</div>

<Mermaid chart={`
graph TB
    subgraph "ã‚³ãƒãƒ³ãƒ‰å´ (æ›¸ãè¾¼ã¿)"
        CMD[ğŸ“ ã‚³ãƒãƒ³ãƒ‰] --> VALIDATE[âœ… æ¤œè¨¼]
        VALIDATE --> AGGREGATE[ğŸ“¦ é›†ç´„]
        AGGREGATE --> EVENT[ğŸ“… ã‚¤ãƒ™ãƒ³ãƒˆç”Ÿæˆ]
        EVENT --> STORE[ğŸ’¾ ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢]
    end
    
    subgraph "ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ "
        STORE --> STREAM[ğŸŒŠ ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ]
        STREAM --> HANDLER[ğŸ”„ ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼]
        HANDLER --> PROJECTION[ğŸ“Š ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°]
    end
    
    subgraph "ã‚¯ã‚¨ãƒªå´ (èª­ã¿è¾¼ã¿)"
        PROJECTION --> READ_DB[ğŸ“– èª­ã¿å–ã‚Šå°‚ç”¨DB]
        READ_DB --> QUERY[ğŸ” ã‚¯ã‚¨ãƒª]
        QUERY --> VIEW[ğŸ‘ï¸ ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«]
    end
    
    subgraph "WebSocketçµ±åˆ"
        HANDLER --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> PUSH[ğŸ“¡ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é…ä¿¡]
        PUSH --> CLIENT[ğŸ‘¤ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ]
    end
    
    subgraph "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ç¨®é¡"
        PROJECTION --> USER_VIEW[ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ“ãƒ¥ãƒ¼]
        PROJECTION --> ORDER_VIEW[ğŸ“¦ æ³¨æ–‡ãƒ“ãƒ¥ãƒ¼]
        PROJECTION --> ANALYTICS[ğŸ“ˆ åˆ†æãƒ“ãƒ¥ãƒ¼]
    end
    
    style AGGREGATE fill:#f3e5f5
    style STREAM fill:#e8f5e8
    style WS fill:#fff3e0
    style READ_DB fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### åˆ†æ•£ãƒ‡ãƒ¼ã‚¿åŒæœŸ

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant A as ãƒãƒ¼ãƒ‰A
    participant C as Coordinator
    participant B as ãƒãƒ¼ãƒ‰B
    participant D as ãƒãƒ¼ãƒ‰C
    participant W as WebSocketã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

    Note over A,W: åˆ†æ•£æ›¸ãè¾¼ã¿å‡¦ç†
    
    A->>C: æ›¸ãè¾¼ã¿è¦æ±‚
    C->>C: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³IDç”Ÿæˆ
    
    par 2ãƒ•ã‚§ãƒ¼ã‚ºã‚³ãƒŸãƒƒãƒˆæº–å‚™
        C->>A: PREPARE
        C->>B: PREPARE  
        C->>D: PREPARE
    end
    
    par å¿œç­”å¾…ã¡
        A->>C: PREPARED
        B->>C: PREPARED
        D->>C: PREPARED
    end
    
    C->>C: å…¨ãƒãƒ¼ãƒ‰æº–å‚™å®Œäº†ç¢ºèª
    
    par ã‚³ãƒŸãƒƒãƒˆå®Ÿè¡Œ
        C->>A: COMMIT
        C->>B: COMMIT
        C->>D: COMMIT
    end
    
    par ã‚³ãƒŸãƒƒãƒˆå®Œäº†
        A->>C: COMMITTED
        B->>C: COMMITTED
        D->>C: COMMITTED
    end
    
    C->>W: å¤‰æ›´é€šçŸ¥é…ä¿¡
    W->>W: ãƒ‡ãƒ¼ã‚¿æ›´æ–°åæ˜ 
    
    Note over A,W: åˆ†æ•£ä¸€è²«æ€§ä¿è¨¼
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 4. ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹çµ±åˆ

### FaaS + WebSocketã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

</div>
</div>

<Mermaid chart={`
graph TD
    subgraph "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå±¤"
        CLIENT[ğŸ“± ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ] --> APIGW[ğŸŒ API Gateway]
    end
    
    subgraph "WebSocketç®¡ç†"
        APIGW --> WSAPI[ğŸ”Œ WebSocket API]
        WSAPI --> CONNECT[ğŸ”— æ¥ç¶šç®¡ç†]
        CONNECT --> DYNAMODB[ğŸ’¾ æ¥ç¶šDB]
    end
    
    subgraph "ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†"
        WSAPI --> SQS[ğŸ“¤ SQSã‚­ãƒ¥ãƒ¼]
        SQS --> LAMBDA[âš¡ Lambdaé–¢æ•°]
        LAMBDA --> BUSINESS[ğŸ”§ ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯]
    end
    
    subgraph "ãƒ‡ãƒ¼ã‚¿å‡¦ç†"
        BUSINESS --> RDS[ğŸ—„ï¸ RDSãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹]
        BUSINESS --> S3[ğŸ“¦ S3ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸]
        BUSINESS --> REDIS[âš¡ ElastiCache]
    end
    
    subgraph "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…ä¿¡"
        BUSINESS --> SNS[ğŸ“¢ SNSé€šçŸ¥]
        SNS --> FANOUT[ğŸ“¡ ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆ]
        FANOUT --> LAMBDA2[âš¡ é…ä¿¡Lambda]
        LAMBDA2 --> WSAPI
    end
    
    subgraph "ç›£è¦–ãƒ»ãƒ­ã‚°"
        LAMBDA --> CLOUDWATCH[ğŸ“Š CloudWatch]
        LAMBDA2 --> CLOUDWATCH
        CLOUDWATCH --> ALARM[ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒ ]
    end
    
    style WSAPI fill:#f3e5f5
    style LAMBDA fill:#e8f5e8
    style SNS fill:#fff3e0
    style CLOUDWATCH fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 5. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼çµ±åˆ

### é«˜ä¿¡é ¼æ€§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°

</div>
</div>

<Mermaid chart={`
graph LR
    subgraph "ãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼"
        SERVICE[ğŸ”§ ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹] --> KAFKA[ğŸ“¡ Kafka Producer]
        KAFKA --> PARTITION[ğŸ“Š ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³]
    end
    
    subgraph "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼"
        PARTITION --> CLUSTER[ğŸŒ Kafkaã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼]
        CLUSTER --> REPLICA[ğŸ“‹ ãƒ¬ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³]
        REPLICA --> PERSISTENCE[ğŸ’¾ æ°¸ç¶šåŒ–]
    end
    
    subgraph "ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼"
        CLUSTER --> WS_CONSUMER[ğŸ”Œ WebSocketã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼]
        CLUSTER --> EMAIL_CONSUMER[ğŸ“§ ãƒ¡ãƒ¼ãƒ«ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼]
        CLUSTER --> ANALYTICS_CONSUMER[ğŸ“Š åˆ†æã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼]
    end
    
    subgraph "WebSocketé…ä¿¡"
        WS_CONSUMER --> FILTER[ğŸ” ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°]
        FILTER --> TRANSFORM[ğŸ”„ ãƒ‡ãƒ¼ã‚¿å¤‰æ›]
        TRANSFORM --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> CLIENT[ğŸ‘¤ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ]
    end
    
    subgraph "ä¿¡é ¼æ€§ä¿è¨¼"
        WS_CONSUMER --> ACK[âœ… é…ä¿¡ç¢ºèª]
        ACK --> RETRY[ğŸ”„ å†é€åˆ¶å¾¡]
        RETRY --> DLQ[ğŸ’€ Dead Letter Queue]
    end
    
    style CLUSTER fill:#f3e5f5
    style WS_CONSUMER fill:#e8f5e8
    style FILTER fill:#fff3e0
    style ACK fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é †åºä¿è¨¼

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant P as ãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼
    participant K as Kafkaãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼
    participant WS as WebSocketã‚µãƒ¼ãƒãƒ¼
    participant C1 as ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ1
    participant C2 as ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ2

    Note over P,C2: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é †åºä¿è¨¼ã‚·ãƒŠãƒªã‚ª
    
    P->>K: Message 1 (Key: user123, Offset: 100)
    P->>K: Message 2 (Key: user123, Offset: 101)
    P->>K: Message 3 (Key: user123, Offset: 102)
    
    Note over K: åŒä¸€ã‚­ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯åŒä¸€ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³
    
    K->>WS: é †æ¬¡ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒ  (Offseté †)
    WS->>WS: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆ¥é…ä¿¡ã‚­ãƒ¥ãƒ¼ä½œæˆ
    
    WS->>C1: Message 1 é…ä¿¡
    C1->>WS: ACKå—ä¿¡
    WS->>C1: Message 2 é…ä¿¡
    C1->>WS: ACKå—ä¿¡
    WS->>C1: Message 3 é…ä¿¡
    
    alt é…ä¿¡å¤±æ•—æ™‚
        WS->>C2: Message 1 é…ä¿¡
        Note over C2: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³
        WS->>WS: å†é€å¾…ã¡ã‚­ãƒ¥ãƒ¼ã«ä¿æŒ
        WS->>C2: Message 1 å†é€
        C2->>WS: ACKå—ä¿¡
        WS->>C2: Message 2 é…ä¿¡ (é †åºä¿è¨¼)
    end
    
    Note over P,C2: ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¥é †åºä¿è¨¼å®Œäº†
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## ğŸ’¡ å®Ÿè£…ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. API Gateway WebSocketçµ±åˆ
```javascript
class WebSocketGateway {
  constructor() {
    this.connections = new Map();
    this.routes = new Map();
    this.middlewares = [];
    this.rateLimiter = new RateLimiter();
  }
  
  async handleConnection(ws, request) {
    // èªè¨¼ãƒ»èªå¯
    const token = this.extractToken(request);
    const user = await this.authenticateToken(token);
    
    if (!user) {
      ws.close(1008, 'Unauthorized');
      return;
    }
    
    // æ¥ç¶šç®¡ç†
    const connectionId = this.generateConnectionId();
    this.connections.set(connectionId, {
      ws,
      user,
      subscriptions: new Set(),
      lastActivity: Date.now()
    });
    
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
    ws.on('message', async (data) => {
      await this.routeMessage(connectionId, data);
    });
    
    ws.on('close', () => {
      this.connections.delete(connectionId);
    });
  }
  
  async routeMessage(connectionId, data) {
    const connection = this.connections.get(connectionId);
    if (!connection) return;
    
    try {
      const message = JSON.parse(data);
      
      // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
      if (!this.rateLimiter.checkLimit(connection.user.id)) {
        connection.ws.send(JSON.stringify({
          error: 'Rate limit exceeded'
        }));
        return;
      }
      
      // ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
      const handler = this.routes.get(message.type);
      if (handler) {
        await handler(connection, message);
      }
      
    } catch (error) {
      console.error('Message routing error:', error);
      connection.ws.send(JSON.stringify({
        error: 'Invalid message format'
      }));
    }
  }
  
  registerRoute(messageType, handler) {
    this.routes.set(messageType, handler);
  }
  
  broadcastToSubscribers(topic, message) {
    for (const [id, connection] of this.connections) {
      if (connection.subscriptions.has(topic)) {
        connection.ws.send(JSON.stringify(message));
      }
    }
  }
}
```

### 2. ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹
```javascript
class EventDrivenService {
  constructor(serviceName) {
    this.serviceName = serviceName;
    this.eventBus = new EventBus();
    this.handlers = new Map();
    this.saga = new SagaOrchestrator();
  }
  
  async publishEvent(eventType, payload) {
    const event = {
      id: uuidv4(),
      type: eventType,
      source: this.serviceName,
      timestamp: new Date().toISOString(),
      payload
    };
    
    // ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢ä¿å­˜
    await this.eventStore.append(event);
    
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã«ç™ºè¡Œ
    await this.eventBus.publish(eventType, event);
    
    // WebSocketé…ä¿¡
    this.websocketGateway.broadcastEvent(event);
  }
  
  subscribeToEvent(eventType, handler) {
    this.handlers.set(eventType, handler);
    this.eventBus.subscribe(eventType, async (event) => {
      try {
        await handler(event);
        // å‡¦ç†æˆåŠŸã‚’ãƒ­ã‚°
        this.logEventProcessing(event, 'success');
      } catch (error) {
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        this.logEventProcessing(event, 'error', error);
        await this.handleEventError(event, error);
      }
    });
  }
  
  async handleEventError(event, error) {
    // å†è©¦è¡Œãƒ­ã‚¸ãƒƒã‚¯
    if (event.retryCount < 3) {
      event.retryCount = (event.retryCount || 0) + 1;
      setTimeout(() => {
        this.eventBus.publish(event.type, event);
      }, Math.pow(2, event.retryCount) * 1000);
    } else {
      // Dead Letter Queue ã«é€ä¿¡
      await this.deadLetterQueue.send(event, error);
    }
  }
  
  startSaga(sagaType, initialEvent) {
    return this.saga.start(sagaType, initialEvent);
  }
}
```

### 3. CQRSå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³
```javascript
class CQRSSystem {
  constructor() {
    this.commandBus = new CommandBus();
    this.queryBus = new QueryBus();
    this.eventStore = new EventStore();
    this.projections = new Map();
  }
  
  // ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
  async executeCommand(command) {
    const handler = this.commandBus.getHandler(command.type);
    
    // é›†ç´„ã®ç¾åœ¨çŠ¶æ…‹ã‚’å–å¾—
    const aggregate = await this.loadAggregate(command.aggregateId);
    
    // ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè¡Œ
    const events = await handler.handle(aggregate, command);
    
    // ã‚¤ãƒ™ãƒ³ãƒˆä¿å­˜
    await this.eventStore.saveEvents(command.aggregateId, events);
    
    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°
    await this.updateProjections(events);
    
    // WebSocketé…ä¿¡
    await this.broadcastEvents(events);
    
    return events;
  }
  
  // ã‚¯ã‚¨ãƒªå‡¦ç†
  async executeQuery(query) {
    const handler = this.queryBus.getHandler(query.type);
    const projection = this.projections.get(query.projectionType);
    
    return await handler.handle(projection, query);
  }
  
  async updateProjections(events) {
    for (const event of events) {
      const projectionHandlers = this.getProjectionHandlers(event.type);
      
      await Promise.all(
        projectionHandlers.map(handler => handler.handle(event))
      );
    }
  }
  
  async broadcastEvents(events) {
    for (const event of events) {
      // é–¢ä¿‚ã™ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã®ã¿é…ä¿¡
      const subscribers = await this.getEventSubscribers(event);
      
      subscribers.forEach(connection => {
        connection.send(JSON.stringify({
          type: 'event',
          event: event
        }));
      });
    }
  }
}
```

### 4. ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹WebSocketç®¡ç†
```javascript
// AWS Lambda + API Gateway WebSocket
exports.handler = async (event, context) => {
  const { requestContext } = event;
  const { connectionId, routeKey } = requestContext;
  
  const apiGateway = new AWS.ApiGatewayManagementApi({
    endpoint: process.env.WEBSOCKET_ENDPOINT
  });
  
  try {
    switch (routeKey) {
      case '$connect':
        await handleConnect(connectionId, event);
        break;
        
      case '$disconnect':
        await handleDisconnect(connectionId);
        break;
        
      case 'message':
        await handleMessage(connectionId, JSON.parse(event.body));
        break;
        
      default:
        console.log('Unknown route:', routeKey);
    }
    
    return { statusCode: 200 };
    
  } catch (error) {
    console.error('Error:', error);
    return { statusCode: 500 };
  }
  
  async function handleConnect(connectionId, event) {
    // DynamoDBã«æ¥ç¶šæƒ…å ±ä¿å­˜
    const params = {
      TableName: 'WebSocketConnections',
      Item: {
        connectionId,
        userId: event.requestContext.authorizer?.userId,
        connectedAt: Date.now()
      }
    };
    
    await dynamodb.put(params).promise();
  }
  
  async function handleMessage(connectionId, message) {
    // ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å‡¦ç†
    const result = await processBusinessLogic(message);
    
    // é–¢é€£ã™ã‚‹æ¥ç¶šã«é…ä¿¡
    const connections = await getRelatedConnections(message.targetUsers);
    
    await Promise.all(connections.map(async (conn) => {
      try {
        await apiGateway.postToConnection({
          ConnectionId: conn.connectionId,
          Data: JSON.stringify(result)
        }).promise();
      } catch (error) {
        if (error.statusCode === 410) {
          // ç„¡åŠ¹ãªæ¥ç¶šã‚’å‰Šé™¤
          await removeConnection(conn.connectionId);
        }
      }
    }));
  }
};
```

ã“ã®åŒ…æ‹¬çš„ãªãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰çµ±åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ã‚ˆã‚Šã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ã§ä¿å®ˆæ€§ã®é«˜ã„WebSocketã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚

</div>
</div>