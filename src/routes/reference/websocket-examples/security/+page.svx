---
title: 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ç›£æŸ»ã‚·ã‚¹ãƒ†ãƒ è©³ç´°'
description: 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ã€ä¾µå…¥æ¤œçŸ¥ã€ç›£æŸ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®WebSocketã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£'
---

<script>
  import ReferenceLayout from '$lib/components/common/ReferenceLayout.svelte';
  import Section from '$lib/components/common/Section.svelte';
  import Card from '$lib/components/common/Card.svelte';
  import MermaidLazyLoad from '$lib/components/MermaidLazyLoad.svelte';
  import { idsIpsThreatResponseDiagram, complianceMonitoringDiagram } from '$lib/charts/allCharts.ts';
</script>

<ReferenceLayout
  description="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ã€ä¾µå…¥æ¤œçŸ¥ã€ç›£æŸ»ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®WebSocketã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£"
  referenceCategory="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£"
  title="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ç›£æŸ»ã‚·ã‚¹ãƒ†ãƒ è©³ç´°"
  duration="90-120åˆ†"
  difficulty="ä¸Šç´š"
  prerequisites={[
    "WebSocketã®åŸºæœ¬æ¦‚å¿µ",
    "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºç¤çŸ¥è­˜",
    "ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç†è§£"
  ]}
  sectionTitle="ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹"
  learningObjectives={[
    'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã®WebSocketæ´»ç”¨',
    'èªè¨¼ãƒ»ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã®å®Ÿè£…',
    'ç›£æŸ»ãƒ­ã‚°ãƒ»ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å¯¾å¿œ',
    'ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œè‡ªå‹•åŒ–'
  ]}
>

<Section title="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ " icon="implementation">

<Card title="ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è„…å¨æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ " icon="shield" accentColor="red">

WebSocketãƒ™ãƒ¼ã‚¹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ã®è„…å¨æ¤œçŸ¥ã¨å¯¾å¿œã‚’å®Ÿç¾ã—ã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={`
graph TB
    subgraph "ãƒ‡ãƒ¼ã‚¿åé›†å±¤"
        FIREWALL[ğŸ”¥ ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«] --> SIEM[ğŸ” SIEM ã‚·ã‚¹ãƒ†ãƒ ]
        IDS[ğŸš¨ ä¾µå…¥æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ ] --> SIEM
        ENDPOINT[ğŸ–¥ï¸ ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ] --> SIEM
        NETWORK[ğŸŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–] --> SIEM
        APP[ğŸ“± ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³] --> SIEM
    end
    
    subgraph "åˆ†æã‚¨ãƒ³ã‚¸ãƒ³"
        SIEM --> CORRELATION[ğŸ”„ ç›¸é–¢åˆ†æ]
        CORRELATION --> ML[ğŸ¤– æ©Ÿæ¢°å­¦ç¿’æ¤œçŸ¥]
        ML --> BEHAVIOR[ğŸ“Š è¡Œå‹•åˆ†æ]
        BEHAVIOR --> THREAT[ğŸ¯ è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹]
    end
    
    subgraph "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é…ä¿¡"
        THREAT --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> ALERT[ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆé…ä¿¡]
        ALERT --> DASHBOARD[ğŸ“Š ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰]
        ALERT --> MOBILE[ğŸ“± ãƒ¢ãƒã‚¤ãƒ«é€šçŸ¥]
        ALERT --> EMAIL[ğŸ“§ ãƒ¡ãƒ¼ãƒ«é€šçŸ¥]
    end
    
    subgraph "å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ "
        DASHBOARD --> SOC[ğŸ‘¥ SOCãƒãƒ¼ãƒ ]
        SOC --> RESPONSE[ğŸ”§ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ]
        RESPONSE --> BLOCK[ğŸš« è‡ªå‹•ãƒ–ãƒ­ãƒƒã‚¯]
        RESPONSE --> ISOLATE[ğŸ”’ éš”é›¢å‡¦ç†]
    end
    
    subgraph "è¨¼è·¡ç®¡ç†"
        WS --> AUDIT[ğŸ“‹ ç›£æŸ»ãƒ­ã‚°]
        AUDIT --> COMPLIANCE[âœ… ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹]
        COMPLIANCE --> REPORT[ğŸ“„ ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ]
    end
    
    style SIEM fill:#f3e5f5
    style ML fill:#e8f5e8
    style WS fill:#fff3e0
    style SOC fill:#e3f2fd
    style AUDIT fill:#ffebee
`} />

<Card title="ä¾µå…¥æ¤œçŸ¥ãƒ»é˜²æ­¢ã‚·ã‚¹ãƒ†ãƒ  (IDS/IPS)" icon="warning" accentColor="orange">

IDS/IPSã‚·ã‚¹ãƒ†ãƒ ã¨WebSocketã®çµ±åˆã«ã‚ˆã‚Šã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ã®è„…å¨æ¤œçŸ¥ã¨è‡ªå‹•å¯¾å¿œãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={idsIpsThreatResponseDiagram} />

</Section>

<Section title="èªè¨¼ãƒ»ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ " icon="implementation">

<Card title="ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£" icon="lock" accentColor="purple">

ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«ã«åŸºã¥ãèªè¨¼ãƒ»ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={`
graph TD
    subgraph "ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼"
        USER[ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼] --> MFA[ğŸ” å¤šè¦ç´ èªè¨¼]
        MFA --> BIOMETRIC[ğŸ‘† ç”Ÿä½“èªè¨¼]
        BIOMETRIC --> DEVICE[ğŸ“± ãƒ‡ãƒã‚¤ã‚¹èªè¨¼]
    end
    
    subgraph "èªè¨¼ã‚·ã‚¹ãƒ†ãƒ "
        DEVICE --> AUTHZ[ğŸ›¡ï¸ èªè¨¼ã‚µãƒ¼ãƒãƒ¼]
        AUTHZ --> POLICY[ğŸ“‹ ãƒãƒªã‚·ãƒ¼ã‚¨ãƒ³ã‚¸ãƒ³]
        POLICY --> RBAC[ğŸ‘¥ RBAC]
        RBAC --> ABAC[ğŸ¯ ABAC]
    end
    
    subgraph "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–"
        AUTHZ --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> SESSION[ğŸ“Š ã‚»ãƒƒã‚·ãƒ§ãƒ³ç›£è¦–]
        SESSION --> ANOMALY[ğŸš¨ ç•°å¸¸æ¤œçŸ¥]
        ANOMALY --> RISK[ğŸ“Š ãƒªã‚¹ã‚¯è©•ä¾¡]
    end
    
    subgraph "é©å¿œåˆ¶å¾¡"
        RISK --> ADAPTIVE[ğŸ”„ é©å¿œèªè¨¼]
        ADAPTIVE --> STEPUP[ğŸ“ˆ æ®µéšèªè¨¼]
        STEPUP --> CHALLENGE[â“ è¿½åŠ èªè¨¼]
        CHALLENGE --> RESTRICT[ğŸš« ã‚¢ã‚¯ã‚»ã‚¹åˆ¶é™]
    end
    
    subgraph "ç›£æŸ»ãƒ»ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹"
        WS --> AUTHLOG[ğŸ“‹ èªè¨¼ãƒ­ã‚°]
        AUTHLOG --> GDPR[ğŸ‡ªğŸ‡º GDPRå¯¾å¿œ]
        GDPR --> SOX[ğŸ“Š SOXæ³•å¯¾å¿œ]
        SOX --> AUDIT[ğŸ” ç›£æŸ»è¨¼è·¡]
    end
    
    style AUTHZ fill:#f3e5f5
    style WS fill:#e8f5e8
    style ANOMALY fill:#ffebee
    style ADAPTIVE fill:#fff3e0
    style AUDIT fill:#e3f2fd
`} />

<Card title="ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ãƒ»ç›£è¦–" icon="monitor" accentColor="blue">

WebSocketã‚’æ´»ç”¨ã—ãŸãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚»ãƒƒã‚·ãƒ§ãƒ³ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={`
graph TB
    subgraph "ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ"
        LOGIN[ğŸ”‘ ãƒ­ã‚°ã‚¤ãƒ³] --> TOKEN[ğŸ« JWTãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ]
        TOKEN --> FINGERPRINT[ğŸ‘† ãƒ‡ãƒã‚¤ã‚¹ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ]
        FINGERPRINT --> SESSION[ğŸ“‹ ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†]
    end
    
    subgraph "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–"
        SESSION --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> ACTIVITY[ğŸ“Š ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ç›£è¦–]
        ACTIVITY --> GEO[ğŸŒ åœ°ç†çš„ä½ç½®ç¢ºèª]
        GEO --> CONCURRENT[ğŸ“± åŒæ™‚ã‚»ãƒƒã‚·ãƒ§ãƒ³ç›£è¦–]
    end
    
    subgraph "ç•°å¸¸æ¤œçŸ¥"
        CONCURRENT --> DETECT[ğŸš¨ ç•°å¸¸æ¤œçŸ¥]
        DETECT --> IMPOSSIBLE[âš¡ ä¸å¯èƒ½ç§»å‹•]
        DETECT --> SUSPICIOUS[ğŸ” ç–‘ã‚ã—ã„è¡Œå‹•]
        DETECT --> BRUTE[ğŸ’¥ ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹]
    end
    
    subgraph "è‡ªå‹•å¯¾å¿œ"
        BRUTE --> TERMINATE[âŒ ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†]
        SUSPICIOUS --> CHALLENGE[â“ è¿½åŠ èªè¨¼è¦æ±‚]
        IMPOSSIBLE --> BLOCK[ğŸš« IPãƒ–ãƒ­ãƒƒã‚¯]
        TERMINATE --> NOTIFY[ğŸ“¢ ãƒ¦ãƒ¼ã‚¶ãƒ¼é€šçŸ¥]
    end
    
    style SESSION fill:#f3e5f5
    style WS fill:#e8f5e8
    style DETECT fill:#ffebee
    style TERMINATE fill:#fff3e0
`} />

</Section>

<Section title="ç›£æŸ»ãƒ­ã‚°ãƒ»ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚·ã‚¹ãƒ†ãƒ " icon="implementation">

<Card title="åŒ…æ‹¬çš„ç›£æŸ»ãƒ­ã‚°åé›†" icon="file" accentColor="green">

ä¼æ¥­ãƒ¬ãƒ™ãƒ«ã®ç›£æŸ»ãƒ­ã‚°åé›†ã¨ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ã‚’è§£èª¬ã—ã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={`
graph TB
    subgraph "ãƒ­ã‚°ã‚½ãƒ¼ã‚¹"
        APP[ğŸ“± ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³] --> COLLECTOR[ğŸ“Š ãƒ­ã‚°ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼]
        OS[ğŸ–¥ï¸ OSãƒ»ã‚·ã‚¹ãƒ†ãƒ ] --> COLLECTOR
        DB[ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹] --> COLLECTOR
        NETWORK[ğŸŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ©Ÿå™¨] --> COLLECTOR
        SECURITY[ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ©Ÿå™¨] --> COLLECTOR
    end
    
    subgraph "ãƒ­ã‚°å‡¦ç†"
        COLLECTOR --> NORMALIZE[ğŸ”„ æ­£è¦åŒ–]
        NORMALIZE --> ENRICH[ğŸ“ˆ ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆ]
        ENRICH --> CLASSIFY[ğŸ·ï¸ åˆ†é¡]
        CLASSIFY --> INDEX[ğŸ“‚ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹]
    end
    
    subgraph "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æ"
        INDEX --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> STREAM[ğŸŒŠ ã‚¹ãƒˆãƒªãƒ¼ãƒ åˆ†æ]
        STREAM --> PATTERN[ğŸ” ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œç´¢]
        PATTERN --> CORRELATION[ğŸ”„ ç›¸é–¢åˆ†æ]
    end
    
    subgraph "ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥"
        CORRELATION --> THRESHOLD[ğŸ“Š é–¾å€¤ç›£è¦–]
        THRESHOLD --> ALERT[ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ]
        ALERT --> ESCALATION[ğŸ“ˆ ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³]
        ESCALATION --> INCIDENT[ğŸ“‹ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆä½œæˆ]
    end
    
    subgraph "é•·æœŸä¿å­˜ãƒ»æ¤œç´¢"
        INDEX --> ARCHIVE[ğŸ“¦ ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–]
        ARCHIVE --> RETENTION[â³ ä¿æŒæœŸé–“ç®¡ç†]
        RETENTION --> SEARCH[ğŸ” é«˜é€Ÿæ¤œç´¢]
        SEARCH --> FORENSICS[ğŸ”¬ ãƒ•ã‚©ãƒ¬ãƒ³ã‚¸ãƒƒã‚¯åˆ†æ]
    end
    
    style COLLECTOR fill:#f3e5f5
    style WS fill:#e8f5e8
    style CORRELATION fill:#fff3e0
    style ARCHIVE fill:#e3f2fd
`} />

<Card title="ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹è‡ªå‹•åŒ–" icon="check" accentColor="teal">

GDPRã€SOXæ³•ãªã©ã®æ³•è¦åˆ¶ã«å¯¾å¿œã—ãŸã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={complianceMonitoringDiagram} />

</Section>

<Section title="ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã‚·ã‚¹ãƒ†ãƒ " icon="implementation">

<Card title="è‡ªå‹•ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ" icon="gear" accentColor="indigo">

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã®è‡ªå‹•æ¤œçŸ¥ãƒ»å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={`
graph TB
    subgraph "ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæ¤œçŸ¥"
        ALERT[ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆç™ºç”Ÿ] --> TRIAGE[ğŸ” ãƒˆãƒªã‚¢ãƒ¼ã‚¸]
        TRIAGE --> SEVERITY[ğŸ“Š é‡è¦åº¦åˆ¤å®š]
        SEVERITY --> CLASSIFY[ğŸ·ï¸ åˆ†é¡]
    end
    
    subgraph "è‡ªå‹•å¯¾å¿œ"
        CLASSIFY --> PLAYBOOK[ğŸ“‹ ãƒ—ãƒ¬ã‚¤ãƒ–ãƒƒã‚¯é¸æŠ]
        PLAYBOOK --> ISOLATE[ğŸ”’ ã‚·ã‚¹ãƒ†ãƒ éš”é›¢]
        ISOLATE --> COLLECT[ğŸ“Š è¨¼è·¡åé›†]
        COLLECT --> ANALYZE[ğŸ”¬ åˆæœŸåˆ†æ]
    end
    
    subgraph "ãƒãƒ¼ãƒ é€£æº"
        ANALYZE --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> ONCALL[ğŸ“ ã‚ªãƒ³ã‚³ãƒ¼ãƒ«é€šçŸ¥]
        ONCALL --> COLLAB[ğŸ¤ ãƒãƒ¼ãƒ å”èª¿]
        COLLAB --> DECISION[ğŸ¯ å¯¾å¿œåˆ¤æ–­]
    end
    
    subgraph "å¯¾å¿œå®Ÿè¡Œ"
        DECISION --> REMEDIATE[ğŸ”§ ä¿®å¾©ä½œæ¥­]
        REMEDIATE --> CONTAIN[ğŸ›¡ï¸ å°ã˜è¾¼ã‚]
        CONTAIN --> ERADICATE[ğŸ§¹ æ ¹çµ¶]
        ERADICATE --> RECOVER[ğŸ”„ å¾©æ—§]
    end
    
    subgraph "äº‹å¾Œå‡¦ç†"
        RECOVER --> LESSON[ğŸ“š æ•™è¨“æŠ½å‡º]
        LESSON --> UPDATE[ğŸ”„ ãƒ—ãƒ¬ã‚¤ãƒ–ãƒƒã‚¯æ›´æ–°]
        UPDATE --> REPORT[ğŸ“„ å ±å‘Šæ›¸ä½œæˆ]
        REPORT --> COMPLIANCE[âœ… ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å ±å‘Š]
    end
    
    style TRIAGE fill:#f3e5f5
    style WS fill:#e8f5e8
    style REMEDIATE fill:#fff3e0
    style LESSON fill:#e3f2fd
`} />

</Section>

<Section title="è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹çµ±åˆ" icon="implementation">

<Card title="ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è„…å¨æƒ…å ±é…ä¿¡" icon="globe" accentColor="amber">

å¤–éƒ¨è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ã¨ã®çµ±åˆã«ã‚ˆã‚‹åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã‚’è§£èª¬ã—ã¾ã™ã€‚

</Card>

<MermaidLazyLoad chart={`
graph TB
    subgraph "è„…å¨æƒ…å ±æº"
        OSINT[ğŸŒ OSINT] --> FEED[ğŸ“¡ è„…å¨ãƒ•ã‚£ãƒ¼ãƒ‰]
        COMMERCIAL[ğŸ’¼ å•†ç”¨TI] --> FEED
        GOVERNMENT[ğŸ›ï¸ æ”¿åºœæ©Ÿé–¢] --> FEED
        COMMUNITY[ğŸ‘¥ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£] --> FEED
    end
    
    subgraph "æƒ…å ±å‡¦ç†"
        FEED --> PARSE[ğŸ”„ ãƒ‘ãƒ¼ã‚¹å‡¦ç†]
        PARSE --> STIX[ğŸ“‹ STIX/TAXIIå¤‰æ›]
        STIX --> ENRICH[ğŸ“ˆ ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆ]
        ENRICH --> SCORE[ğŸ“Š ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°]
    end
    
    subgraph "é…ä¿¡ã‚·ã‚¹ãƒ†ãƒ "
        SCORE --> WS[WebSocketã‚µãƒ¼ãƒãƒ¼]
        WS --> FILTER[ğŸ” ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°]
        FILTER --> PRIORITY[ğŸ“Š å„ªå…ˆåº¦åˆ¶å¾¡]
        PRIORITY --> DISTRIBUTE[ğŸ“¡ é…ä¿¡]
    end
    
    subgraph "çµ±åˆã‚·ã‚¹ãƒ†ãƒ "
        DISTRIBUTE --> SIEM[ğŸ” SIEMçµ±åˆ]
        DISTRIBUTE --> FIREWALL[ğŸ”¥ ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«]
        DISTRIBUTE --> ENDPOINT[ğŸ–¥ï¸ ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ]
        DISTRIBUTE --> DNS[ğŸŒ DNSè¨­å®š]
    end
    
    subgraph "ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯"
        SIEM --> VALIDATE[âœ… æœ‰åŠ¹æ€§æ¤œè¨¼]
        VALIDATE --> FEEDBACK[ğŸ”„ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯]
        FEEDBACK --> IMPROVE[ğŸ“ˆ æ”¹å–„]
    end
    
    style FEED fill:#f3e5f5
    style WS fill:#e8f5e8
    style DISTRIBUTE fill:#fff3e0
    style VALIDATE fill:#e3f2fd
`} />

</Section>

<Section title="å®Ÿè£…ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹" icon="code">

<Card title="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…ä¾‹" icon="code" accentColor="gray">

### 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆç›£è¦–
```javascript
class SecurityEventMonitor {
  constructor() {
    this.rules = new Map();
    this.correlationEngine = new CorrelationEngine();
    this.threatIntelligence = new ThreatIntelligence();
    this.incidents = new Map();
  }
  
  async processSecurityEvent(event) {
    // ã‚¤ãƒ™ãƒ³ãƒˆæ­£è¦åŒ–
    const normalizedEvent = this.normalizeEvent(event);
    
    // è„…å¨ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ã‚¹ç…§åˆ
    const threatMatch = await this.threatIntelligence.match(normalizedEvent);
    if (threatMatch) {
      normalizedEvent.threatLevel = threatMatch.severity;
      normalizedEvent.indicators = threatMatch.indicators;
    }
    
    // ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ¤œçŸ¥
    const ruleMatches = this.checkRules(normalizedEvent);
    
    // ç›¸é–¢åˆ†æ
    const correlationResult = await this.correlationEngine.analyze(normalizedEvent);
    
    // ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆç”Ÿæˆåˆ¤å®š
    if (this.shouldCreateIncident(ruleMatches, correlationResult)) {
      const incident = await this.createIncident(normalizedEvent, correlationResult);
      await this.notifyIncident(incident);
    }
    
    // WebSocketé…ä¿¡
    this.broadcastSecurityEvent(normalizedEvent);
  }
  
  checkRules(event) {
    const matches = [];
    
    for (const [ruleId, rule] of this.rules) {
      if (this.evaluateRule(rule, event)) {
        matches.push({
          ruleId,
          severity: rule.severity,
          description: rule.description,
          mitre: rule.mitreAttack
        });
      }
    }
    
    return matches;
  }
  
  async createIncident(event, correlation) {
    const incident = {
      id: this.generateIncidentId(),
      severity: this.calculateSeverity(event, correlation),
      title: this.generateTitle(event),
      description: this.generateDescription(event, correlation),
      timeline: [event],
      status: 'open',
      assignee: null,
      createdAt: new Date(),
      artifacts: this.extractArtifacts(event)
    };
    
    this.incidents.set(incident.id, incident);
    
    // è‡ªå‹•å¯¾å¿œã®å®Ÿè¡Œ
    await this.executePlaybook(incident);
    
    return incident;
  }
  
  broadcastSecurityEvent(event) {
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«é…ä¿¡
    this.websocket.broadcast('security_event', {
      type: 'security_event',
      event: event,
      timestamp: Date.now()
    });
    
    // é«˜å„ªå…ˆåº¦ã‚¤ãƒ™ãƒ³ãƒˆã¯å³åº§é€šçŸ¥
    if (event.priority === 'high' || event.priority === 'critical') {
      this.websocket.broadcast('urgent_alert', {
        type: 'urgent_alert',
        message: `High priority security event: ${event.title}`,
        event: event
      });
    }
  }
}
```

### 2. èªè¨¼ã‚»ãƒƒã‚·ãƒ§ãƒ³ç›£è¦–
```javascript
class AuthenticationMonitor {
  constructor() {
    this.sessions = new Map();
    this.riskEngine = new RiskEngine();
    this.geoLocation = new GeoLocationService();
    this.deviceFingerprinting = new DeviceFingerprinting();
  }
  
  async monitorAuthentication(authEvent) {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±æ›´æ–°
    const session = await this.updateSession(authEvent);
    
    // ãƒªã‚¹ã‚¯è©•ä¾¡
    const riskScore = await this.calculateRiskScore(authEvent, session);
    
    // ç•°å¸¸æ¤œçŸ¥
    const anomalies = await this.detectAnomalies(authEvent, session);
    
    // WebSocketé…ä¿¡
    this.broadcastAuthEvent({
      type: 'authentication_event',
      user: authEvent.userId,
      action: authEvent.action,
      riskScore: riskScore,
      anomalies: anomalies,
      session: session.id
    });
    
    // é«˜ãƒªã‚¹ã‚¯ã®å ´åˆã¯è¿½åŠ èªè¨¼
    if (riskScore > 0.8) {
      await this.requestStepUpAuthentication(session);
    }
    
    // ç•°å¸¸æ¤œçŸ¥ã®å ´åˆã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ç›£è¦–å¼·åŒ–
    if (anomalies.length > 0) {
      await this.enhanceSessionMonitoring(session);
    }
  }
  
  async calculateRiskScore(authEvent, session) {
    const factors = [];
    
    // åœ°ç†çš„è¦å› 
    const geoRisk = await this.assessGeographicRisk(authEvent.ipAddress, session.user);
    factors.push({ type: 'geographic', score: geoRisk });
    
    // ãƒ‡ãƒã‚¤ã‚¹è¦å› 
    const deviceRisk = await this.assessDeviceRisk(authEvent.deviceFingerprint, session.user);
    factors.push({ type: 'device', score: deviceRisk });
    
    // è¡Œå‹•è¦å› 
    const behaviorRisk = await this.assessBehaviorRisk(authEvent, session.user);
    factors.push({ type: 'behavior', score: behaviorRisk });
    
    // æ™‚é–“è¦å› 
    const temporalRisk = await this.assessTemporalRisk(authEvent.timestamp, session.user);
    factors.push({ type: 'temporal', score: temporalRisk });
    
    return this.riskEngine.calculateCompositeScore(factors);
  }
  
  async detectAnomalies(authEvent, session) {
    const anomalies = [];
    
    // ä¸å¯èƒ½ç§»å‹•æ¤œçŸ¥
    const impossibleTravel = await this.detectImpossibleTravel(authEvent, session);
    if (impossibleTravel) {
      anomalies.push({
        type: 'impossible_travel',
        severity: 'high',
        details: impossibleTravel
      });
    }
    
    // åŒæ™‚å¤šåœ°ç‚¹ãƒ­ã‚°ã‚¤ãƒ³
    const concurrentLogins = await this.detectConcurrentLogins(authEvent, session);
    if (concurrentLogins.length > 1) {
      anomalies.push({
        type: 'concurrent_logins',
        severity: 'medium',
        details: concurrentLogins
      });
    }
    
    // ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒ
    const bruteForce = await this.detectBruteForce(authEvent);
    if (bruteForce) {
      anomalies.push({
        type: 'brute_force',
        severity: 'high',
        details: bruteForce
      });
    }
    
    return anomalies;
  }
}
```

### 3. ç›£æŸ»ãƒ­ã‚°å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ 
```javascript
class AuditLogProcessor {
  constructor() {
    this.complianceRules = new Map();
    this.retentionPolicies = new Map();
    this.encryptionKeys = new EncryptionKeyManager();
  }
  
  async processAuditLog(logEntry) {
    // ãƒ­ã‚°æ­£è¦åŒ–
    const normalizedLog = this.normalizeLog(logEntry);
    
    // ãƒ‡ã‚¸ã‚¿ãƒ«ç½²å
    const signedLog = await this.signLog(normalizedLog);
    
    // æš—å·åŒ–
    const encryptedLog = await this.encryptLog(signedLog);
    
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
    await this.indexLog(encryptedLog);
    
    // ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯
    const complianceResults = await this.checkCompliance(normalizedLog);
    
    // WebSocketé…ä¿¡ï¼ˆé‡è¦ãªã‚¤ãƒ™ãƒ³ãƒˆã®ã¿ï¼‰
    if (this.shouldBroadcast(normalizedLog)) {
      this.broadcastAuditEvent(normalizedLog, complianceResults);
    }
    
    // ä¿æŒæœŸé–“ç®¡ç†
    await this.applyRetentionPolicy(encryptedLog);
    
    return {
      logId: encryptedLog.id,
      complianceStatus: complianceResults,
      retentionDate: encryptedLog.retentionDate
    };
  }
  
  async checkCompliance(logEntry) {
    const results = [];
    
    for (const [ruleId, rule] of this.complianceRules) {
      const result = await this.evaluateComplianceRule(rule, logEntry);
      if (!result.compliant) {
        results.push({
          ruleId: ruleId,
          regulation: rule.regulation,
          violation: result.violation,
          severity: result.severity,
          remediation: result.remediation
        });
      }
    }
    
    return results;
  }
  
  broadcastAuditEvent(logEntry, complianceResults) {
    const event = {
      type: 'audit_event',
      category: logEntry.category,
      user: logEntry.user,
      action: logEntry.action,
      resource: logEntry.resource,
      timestamp: logEntry.timestamp,
      complianceStatus: complianceResults.length === 0 ? 'compliant' : 'violation',
      violations: complianceResults
    };
    
    // é•åãŒã‚ã£ãŸå ´åˆã¯å³åº§é€šçŸ¥
    if (complianceResults.length > 0) {
      this.websocket.broadcast('compliance_violation', {
        type: 'compliance_violation',
        event: event,
        urgency: this.calculateUrgency(complianceResults)
      });
    }
    
    // é€šå¸¸ã®ç›£æŸ»ã‚¤ãƒ™ãƒ³ãƒˆé…ä¿¡
    this.websocket.broadcast('audit_log', event);
  }
}
```

### 4. ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œè‡ªå‹•åŒ–
```javascript
class IncidentResponseAutomation {
  constructor() {
    this.playbooks = new Map();
    this.workflows = new Map();
    this.approvals = new Map();
  }
  
  async executePlaybook(incident) {
    const playbook = this.selectPlaybook(incident);
    if (!playbook) return;
    
    const execution = {
      id: this.generateExecutionId(),
      incidentId: incident.id,
      playbookId: playbook.id,
      status: 'running',
      steps: [],
      startTime: new Date()
    };
    
    // WebSocketçµŒç”±ã§å®Ÿè¡Œé–‹å§‹é€šçŸ¥
    this.broadcastExecution('started', execution);
    
    try {
      for (const step of playbook.steps) {
        const stepResult = await this.executeStep(step, incident, execution);
        execution.steps.push(stepResult);
        
        // ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†é€šçŸ¥
        this.broadcastExecution('step_completed', execution, stepResult);
        
        // äººé–“ã®æ‰¿èªãŒå¿…è¦ãªå ´åˆ
        if (step.requiresApproval) {
          await this.requestApproval(execution, step);
        }
      }
      
      execution.status = 'completed';
      execution.endTime = new Date();
      
    } catch (error) {
      execution.status = 'failed';
      execution.error = error.message;
      execution.endTime = new Date();
    }
    
    // å®Ÿè¡Œå®Œäº†é€šçŸ¥
    this.broadcastExecution('completed', execution);
    
    return execution;
  }
  
  async executeStep(step, incident, execution) {
    const stepResult = {
      stepId: step.id,
      name: step.name,
      startTime: new Date(),
      status: 'running'
    };
    
    try {
      switch (step.type) {
        case 'isolate_system':
          await this.isolateSystem(step.target);
          break;
          
        case 'block_ip':
          await this.blockIP(step.ipAddress);
          break;
          
        case 'collect_evidence':
          stepResult.evidence = await this.collectEvidence(step.targets);
          break;
          
        case 'notify_team':
          await this.notifyTeam(step.team, incident);
          break;
          
        case 'run_script':
          stepResult.output = await this.runScript(step.script, step.parameters);
          break;
      }
      
      stepResult.status = 'completed';
      stepResult.endTime = new Date();
      
    } catch (error) {
      stepResult.status = 'failed';
      stepResult.error = error.message;
      stepResult.endTime = new Date();
    }
    
    return stepResult;
  }
  
  broadcastExecution(event, execution, stepResult = null) {
    this.websocket.broadcast('playbook_execution', {
      type: 'playbook_execution',
      event: event,
      execution: {
        id: execution.id,
        incidentId: execution.incidentId,
        status: execution.status,
        currentStep: stepResult?.stepId,
        progress: this.calculateProgress(execution)
      },
      stepResult: stepResult
    });
  }
}
```

ã“ã®åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ç›£æŸ»ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ã‚ˆã‚Šã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ã®è„…å¨æ¤œçŸ¥ã¨å¯¾å¿œãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

</Card>

</Section>

</ReferenceLayout>