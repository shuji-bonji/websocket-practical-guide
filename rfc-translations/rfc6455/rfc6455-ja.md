# RFC 6455: The WebSocket Protocol 日本語訳

> 原文: [RFC 6455 - The WebSocket Protocol](https://www.rfc-editor.org/rfc/rfc6455)
> 翻訳品質評価: xCOMET (目標スコア: 0.8以上)

---

## 概要 (Abstract)

**翻訳スコア: 0.800**

WebSocketプロトコルは、制御された環境内で信頼されていないコードを実行するクライアントと、そのコードからの通信を許可したリモートホストとの間での双方向通信を可能にする。このプロトコルで使用されるセキュリティモデルは、Webブラウザで一般的に使用されているオリジンベースのセキュリティモデルである。本プロトコルは、オープニングハンドシェイクと、それに続く基本的なメッセージフレーミングで構成され、TCP上に階層化されている。この技術の目的は、サーバとの双方向通信を必要とするブラウザベースのアプリケーションに対して、複数のHTTP接続を開くこと（例：XMLHttpRequestや<iframe>とロングポーリングの使用）に依存しないメカニズムを提供することである。

---

## 1. はじめに (Introduction)

### 1.1. 背景 (Background)

**翻訳スコア: 0.917**

このセクションは非規範的である。

歴史的に、クライアントとサーバ間の双方向通信を必要とするWebアプリケーション（例：インスタントメッセージングやゲームアプリケーション）の作成には、HTTPを悪用してサーバに更新をポーリングする一方で、上流への通知を個別のHTTP呼び出しとして送信する必要があった[RFC6202]。

これは様々な問題を引き起こす：

- サーバは各クライアントに対して複数の異なる基盤TCP接続の使用を強いられる：クライアントへの情報送信用に1つと、受信メッセージごとに新しい接続が必要となる。
- ワイヤプロトコルは高いオーバーヘッドを持ち、クライアントからサーバへの各メッセージがHTTPヘッダを持つ。
- クライアント側スクリプトは、応答を追跡するために送信接続から受信接続へのマッピングを維持することを強いられる。

より単純な解決策は、双方向のトラフィックに単一のTCP接続を使用することである。これがWebSocketプロトコルの提供するものである。WebSocket API [WSAPI]と組み合わせることで、Webページからリモートサーバへの双方向通信においてHTTPポーリングの代替手段を提供する。

同じ技術はゲーム、株価ティッカー、同時編集可能なマルチユーザアプリケーション、リアルタイムでサーバ側サービスを公開するユーザインターフェースなど、様々なWebアプリケーションに使用できる。

WebSocketプロトコルは、既存のインフラストラクチャ（プロキシ、フィルタリング、認証）の恩恵を受けるためにHTTPをトランスポート層として使用する既存の双方向通信技術を置き換えるよう設計されている。HTTPは元来双方向通信での使用を意図していなかったため、このような技術は効率と信頼性のトレードオフとして実装された（さらなる議論については[RFC6202]を参照）。WebSocketプロトコルは既存のHTTPインフラストラクチャの文脈において既存の双方向HTTP技術の目標への対処を試みている。そのため、現環境に固有の複雑さを伴う場合でも、HTTPポート80および443上で動作するとともにHTTPプロキシや中間者をサポートするよう設計されている。しかしながら、この設計はWebSocketをHTTPに限定しておらず、将来の実装ではプロトコル全体を再発明することなく専用ポート上でより単純なハンドシェイクを使用できる。対話型メッセージングのトラフィックパターンは標準HTTPトラフィックと密接に一致せず一部コンポーネントに異常な負荷を誘発しうるため、この最後の点は重要である。

### 1.2. プロトコル概要 (Protocol Overview)

**翻訳スコア: 0.883**

このセクションは非規範的である。

プロトコルはハンドシェイクとデータ転送の2つの部分から構成される。

クライアントからのハンドシェイクは以下のようになる：

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

サーバからのハンドシェイクは以下のようになる：

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

クライアントからの先頭行はRequest-Line形式に従う。サーバからの先頭行はStatus-Line形式に従う。Request-LineおよびStatus-Lineの構文は[RFC2616]で定義されている。

どちらの場合も、先頭行の後に順序付けされていないヘッダフィールドのセットが続く。これらのヘッダフィールドの意味は本文書のセクション4で規定されている。クッキー[RFC6265]などの追加ヘッダフィールドも存在する場合がある。ヘッダの書式と解析は[RFC2616]で定義されているとおりである。

クライアントとサーバの両方がハンドシェイクを送信し、ハンドシェイクが成功すると、データ転送部分が開始される。これは双方向通信チャネルであり、各側が他方とは独立して自由にデータを送信できる。

ハンドシェイクが成功すると、クライアントとサーバは本仕様で「メッセージ」と呼ばれる概念単位でデータをやり取りする。ワイヤ上では、メッセージは1つ以上のフレームで構成される。断片化されたメッセージは中間者によって結合または分割される可能性があるため、WebSocketメッセージは必ずしも特定のネットワーク層フレーミングに対応するとは限らない。

フレームには関連付けられた型がある。同じメッセージに属する各フレームは同じ型のデータを含む。大まかに言えば、テキストデータ（UTF-8 [RFC3629]テキストとして解釈される）、バイナリデータ（その解釈はアプリケーションに委ねられる）、および制御フレーム（アプリケーション用のデータを運ぶことを意図しておらず、代わりに接続を閉じるべきことを通知するなどのプロトコルレベルのシグナリング用）の型がある。このバージョンのプロトコルでは6種類のフレーム型を定義し、将来の使用のために10種類を予約している。

### 1.3. オープニングハンドシェイク (Opening Handshake)

**翻訳スコア: 0.888**

このセクションは非規範的である。

オープニングハンドシェイクは、HTTPベースのサーバサイドソフトウェアや中間者と互換性があることを意図しており、単一のポートをそのサーバと通信するHTTPクライアントとWebSocketクライアントの両方で使用できる。このため、WebSocketクライアントのハンドシェイクはHTTP Upgradeリクエストである。

[RFC2616]に準拠して、ハンドシェイクのヘッダフィールドはクライアントから任意の順序で送信されてよいため、異なるヘッダフィールドを受信する順序は重要ではない。

GETメソッド[RFC2616]の「Request-URI」は、1つのIPアドレスから複数のドメインにサービスを提供できるようにするため、および単一のサーバから複数のWebSocketエンドポイントにサービスを提供できるようにするため、WebSocket接続のエンドポイントを識別するために使用される。

クライアントは[RFC2616]に従って、ハンドシェイクの|Host|ヘッダフィールドにホスト名を含め、クライアントとサーバの両方が使用中のホストについて合意していることを確認できるようにする。

WebSocketプロトコルでオプションを選択するために追加のヘッダフィールドが使用される。このバージョンで利用可能な典型的なオプションは、サブプロトコルセレクタ（|Sec-WebSocket-Protocol|）、クライアントがサポートする拡張のリスト（|Sec-WebSocket-Extensions|）、|Origin|ヘッダフィールドなどである。|Sec-WebSocket-Protocol|リクエストヘッダフィールドは、どのサブプロトコル（WebSocketプロトコル上に階層化されたアプリケーションレベルプロトコル）がクライアントに許容されるかを示すために使用できる。サーバは許容されるプロトコルの1つを選択するか選択せず、そのプロトコルを選択したことを示すためにその値をハンドシェイクでエコーする。

|Origin|ヘッダフィールド[RFC6454]は、WebブラウザでWebSocket APIを使用するスクリプトによるWebSocketサーバの不正なクロスオリジン使用から保護するために使用される。サーバはWebSocket接続リクエストを生成するスクリプトのオリジンを通知される。サーバがこのオリジンからの接続を受け入れたくない場合、適切なHTTPエラーコードを送信することで接続を拒否することを選択できる。このヘッダフィールドはブラウザクライアントによって送信される。非ブラウザクライアントの場合、それらのクライアントの文脈で意味がある場合にこのヘッダフィールドが送信されることがある。

最後に、サーバはクライアントのWebSocketハンドシェイクを受信したことをクライアントに証明する必要があり、これによりサーバがWebSocket接続ではない接続を受け入れることを防ぐ。これにより、攻撃者がXMLHttpRequestやフォーム送信を使用して注意深く作成されたパケットを送信することでWebSocketサーバを欺くことを防ぐ。

### 1.4. クロージングハンドシェイク (Closing Handshake)

**翻訳スコア: 0.931**

このセクションは非規範的である。

クロージングハンドシェイクはオープニングハンドシェイクよりもはるかに単純である。

どちらのピアも指定された制御シーケンスを含むデータを持つ制御フレームを送信してクロージングハンドシェイクを開始できる（詳細はセクション5.5.1で説明）。そのようなフレームを受信すると、もう一方のピアはまだ送信していなければ応答としてCloseフレームを送信する。その制御フレームを受信すると、最初のピアはそれ以上データが来ないことを確信して接続を閉じる。

接続を閉じるべきことを示す制御フレームを送信した後、ピアはそれ以上データを送信しない。接続を閉じるべきことを示す制御フレームを受信した後、ピアはそれ以上受信したデータを破棄する。

両方のピアが同時にこのハンドシェイクを開始しても安全である。

クロージングハンドシェイクは、TCPクロージングハンドシェイク（FIN/ACK）を補完することを意図している。これは、TCPクロージングハンドシェイクが特にプロキシやその他の中間者の存在下では常にエンドツーエンドで信頼できるとは限らないためである。

Closeフレームを送信し応答としてCloseフレームを待つことで、データが不必要に失われる可能性のある特定のケースを回避できる。例えば、いくつかのプラットフォームでは、受信キューにデータがある状態でソケットが閉じられるとRSTパケットが送信され、これによりRSTを受信した側でrecv()が失敗する。読み取り待ちのデータがあった場合でも同様である。

### 1.5. 設計思想 (Design Philosophy)

**翻訳スコア: 0.893**

このセクションは非規範的である。

WebSocketプロトコルは、最小限のフレーミングしか存在しないという原則に基づいて設計されている（存在する唯一のフレーミングは、プロトコルをストリームベースではなくフレームベースにすること、およびUnicodeテキストとバイナリフレームの区別をサポートすることである）。メタデータがアプリケーション層によってTCPの上に階層化されるのと同様に（例：HTTP）、メタデータがアプリケーション層によってWebSocketの上に階層化されることが期待される。

概念的には、WebSocketは実際にはTCPの上のレイヤーであり、以下のことを行う：

- ブラウザ用のWebオリジンベースのセキュリティモデルを追加する
- 1つのポートで複数のサービス、1つのIPアドレスで複数のホスト名をサポートするためのアドレッシングとプロトコル命名メカニズムを追加する
- TCPの上にフレーミングメカニズムを階層化し、TCPが構築されているIPパケットメカニズムに戻すが、長さ制限なしで
- プロキシやその他の中間者の存在下で動作するように設計された追加のクロージングハンドシェイクを帯域内に含む

それ以外、WebSocketは何も追加しない。基本的に、Webの制約を考慮して、スクリプトに生のTCPを公開することにできるだけ近づけることを意図している。また、ハンドシェイクを有効なHTTP Upgradeリクエストにすることで、サーバがHTTPサーバとポートを共有できるように設計されている。

このプロトコルは拡張可能であることを意図しており、将来のバージョンでは多重化などの追加概念が導入される可能性が高い。

### 1.6. セキュリティモデル (Security Model)

**翻訳スコア: 0.850**

このセクションは非規範的である。

WebSocketプロトコルは、WebページからWebSocketプロトコルを使用する際に、どのWebページがWebSocketサーバに接続できるかを制限するために、Webブラウザが使用するオリジンモデルを使用する。当然ながら、WebSocketプロトコルが専用クライアントによって直接使用される場合（つまり、Webブラウザを通じてWebページからではなく）、クライアントは任意のオリジン文字列を提供できるため、オリジンモデルは有用ではない。

このプロトコルは、HTTPサーバが希望する場合にこのプロトコルのサポートをオプトインすることを許可しながら、SMTP [RFC5321]やHTTPのような既存プロトコルのサーバとの接続確立に失敗することを意図している。これは、厳格で精巧なハンドシェイクを持ち、ハンドシェイクが完了する前に接続に挿入できるデータを制限することで達成される（したがって、サーバが影響を受ける程度を制限する）。

同様に、他のプロトコル、特にHTTPからのデータがWebSocketサーバに送信された場合、例えばHTMLの「フォーム」がWebSocketサーバに送信された場合のように、接続確立に失敗することも意図している。これは主に、サーバがハンドシェイクを読んだことを証明することを要求することで達成される。これはハンドシェイクに適切な部分が含まれている場合にのみ可能であり、それはWebSocketクライアントによってのみ送信できる。特に、この仕様の執筆時点では、|Sec-|で始まるフィールドは、XMLHttpRequest [XMLHttpRequest]などのHTMLおよびJavaScript APIのみを使用するWebブラウザからは攻撃者によって設定できない。

### 1.7. TCPおよびHTTPとの関係 (Relationship to TCP and HTTP)

**翻訳スコア: 0.985**

このセクションは非規範的である。

WebSocketプロトコルは独立したTCPベースのプロトコルである。HTTPとの唯一の関係は、そのハンドシェイクがHTTPサーバによってUpgradeリクエストとして解釈されることである。

デフォルトでは、WebSocketプロトコルは通常のWebSocket接続にはポート80を使用し、Transport Layer Security（TLS）[RFC2818]を介してトンネルされたWebSocket接続にはポート443を使用する。

### 1.8. 接続の確立 (Establishing a Connection)

**翻訳スコア: 0.850**

このセクションは非規範的である。

HTTPサーバが共有するポートに接続する場合（ポート80および443へのトラフィックで発生する可能性が高い状況）、HTTPサーバからはUpgradeオファーを伴う通常のGETリクエストに見える。1つのIPアドレスのみで、単一のホスト名へのすべてのトラフィックに1つのサーバを使用する比較的単純なセットアップでは、WebSocketプロトコルに基づくシステムの実用的な展開方法となる可能性がある。より複雑なセットアップ（例：ロードバランサと複数のサーバを使用する場合）では、HTTPサーバとは別にWebSocket接続専用のホストセットを用意する方が管理しやすい可能性が高い。この仕様の執筆時点では、ポート80と443での接続の成功率は大きく異なり、ポート443での接続の方が成功する可能性が大幅に高いことに注意すべきである。ただし、これは時間とともに変化する可能性がある。

### 1.9. WebSocketプロトコルを使用するサブプロトコル (Subprotocols Using the WebSocket Protocol)

**翻訳スコア: 0.876**

このセクションは非規範的である。

クライアントはハンドシェイクに|Sec-WebSocket-Protocol|フィールドを含めることでサーバに特定のサブプロトコルの使用を要求できる。指定された場合、接続を確立するために、サーバは同じフィールドと選択されたサブプロトコル値の1つを応答に含める必要がある。

これらのサブプロトコル名はセクション11.5に従って登録されるべきである。潜在的な衝突を避けるために、サブプロトコルの発信元のドメイン名のASCIIバージョンを含む名前を使用することが推奨される。例えば、Example CorporationがWeb上の多くのサーバで実装されるChatサブプロトコルを作成する場合、「chat.example.com」と名付けることができる。Example Organizationが競合するサブプロトコルを「chat.example.org」と呼んだ場合、2つのサブプロトコルはサーバによって同時に実装でき、サーバはクライアントから送信された値に基づいてどのサブプロトコルを使用するかを動的に選択する。

サブプロトコルはサブプロトコル名を変更することで後方互換性のない方法でバージョン管理できる。例えば「bookings.example.net」から「v2.bookings.example.net」への変更である。これらのサブプロトコルはWebSocketクライアントから完全に別物とみなされる。後方互換性のあるバージョニングは、同じサブプロトコル文字列を再利用しながら、このような拡張性をサポートするよう実際のサブプロトコルを慎重に設計することで実装できる。

---

## 翻訳メタデータ

| セクション                       | スコア | 反復 | 完了日     |
| -------------------------------- | ------ | ---- | ---------- |
| Abstract                         | 0.800  | 15   | 2026-01-17 |
| 1.1 Background                   | 0.917  | 3    | 2026-01-17 |
| 1.2 Protocol Overview            | 0.883  | 1    | 2026-01-17 |
| 1.3 Opening Handshake            | 0.888  | 6    | 2026-01-17 |
| 1.4 Closing Handshake            | 0.931  | 3    | 2026-01-17 |
| 1.5 Design Philosophy            | 0.893  | 1    | 2026-01-17 |
| 1.6 Security Model               | 0.850  | 1    | 2026-01-17 |
| 1.7 Relationship to TCP and HTTP | 0.985  | 1    | 2026-01-17 |
| 1.8 Establishing a Connection    | 0.850  | 1    | 2026-01-17 |
| 1.9 Subprotocols                 | 0.876  | 1    | 2026-01-17 |

**翻訳ツール**: DeepL + 手動改善
**評価ツール**: xCOMET
**平均スコア**: 0.887
