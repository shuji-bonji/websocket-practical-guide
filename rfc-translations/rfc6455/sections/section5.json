{
  "section": "5",
  "title": "Data Framing",
  "title_ja": "データフレーミング",
  "translatedAt": "2026-01-21",
  "status": "completed",
  "subsections": [
    {
      "section": "5.1",
      "title": "Overview",
      "title_ja": "概要",
      "paragraphs": [
        {
          "id": "5.1-p1a",
          "source": "In the WebSocket Protocol, data is transmitted using a sequence of frames.",
          "translation": "WebSocketプロトコルでは、データはフレームのシーケンスを使用して送信される。",
          "score": 0.931,
          "iterations": 1
        },
        {
          "id": "5.1-p1b",
          "source": "To avoid confusing network intermediaries (such as intercepting proxies) and for security reasons that are further discussed in Section 10.3, a client MUST mask all frames that it sends to the server (see Section 5.3 for further details).",
          "translation": "ネットワーク中継者（傍受プロキシなど）を混乱させないため、およびセクション10.3で詳述するセキュリティ上の理由から、クライアントはサーバに送信するすべてのフレームをマスクしなければならない（MUST）（詳細はセクション5.3参照）。",
          "score": 0.75,
          "iterations": 2,
          "needs_review": true
        },
        {
          "id": "5.1-p1c",
          "source": "(Note that masking is done whether or not the WebSocket Protocol is running over TLS.)",
          "translation": "（WebSocketプロトコルがTLS上で動作しているかどうかに関わらず、マスキングは行われることに注意。）",
          "score": 0.85,
          "iterations": 1
        },
        {
          "id": "5.1-p1d",
          "source": "The server MUST close the connection upon receiving a frame that is not masked.",
          "translation": "サーバはマスクされていないフレームを受信した場合、接続を閉じなければならない（MUST）。",
          "score": 0.85,
          "iterations": 1
        },
        {
          "id": "5.1-p1e",
          "source": "In this case, a server MAY send a Close frame with a status code of 1002 (protocol error) as defined in Section 7.4.1.",
          "translation": "この場合、サーバはセクション7.4.1で定義されているステータスコード1002（プロトコルエラー）のCloseフレームを送信してもよい（MAY）。",
          "score": 0.85,
          "iterations": 1
        },
        {
          "id": "5.1-p1f",
          "source": "A server MUST NOT mask any frames that it sends to the client.",
          "translation": "サーバはクライアントに送信するフレームをマスクしてはならない（MUST NOT）。",
          "score": 0.9,
          "iterations": 1
        },
        {
          "id": "5.1-p1g",
          "source": "A client MUST close a connection if it detects a masked frame.",
          "translation": "クライアントはマスクされたフレームを検出した場合、接続を閉じなければならない（MUST）。",
          "score": 0.88,
          "iterations": 1
        },
        {
          "id": "5.1-p1h",
          "source": "In this case, it MAY use the status code 1002 (protocol error) as defined in Section 7.4.1. (These rules might be relaxed in a future specification.)",
          "translation": "この場合、セクション7.4.1で定義されているステータスコード1002（プロトコルエラー）を使用してもよい（MAY）。（これらのルールは将来の仕様で緩和される可能性がある。）",
          "score": 0.85,
          "iterations": 1
        },
        {
          "id": "5.1-p2",
          "source": "The base framing protocol defines a frame type with an opcode, a payload length, and designated locations for \"Extension data\" and \"Application data\", which together define the \"Payload data\". Certain bits and opcodes are reserved for future expansion of the protocol.",
          "translation": "ベースフレーミングプロトコルは、オペコード、ペイロード長、「拡張データ」と「アプリケーションデータ」の指定位置を持つフレームタイプを定義し、これらを合わせて「ペイロードデータ」を定義する。特定のビットとオペコードは将来のプロトコル拡張のために予約されている。",
          "score": 0.835,
          "iterations": 1
        },
        {
          "id": "5.1-p3",
          "source": "A data frame MAY be transmitted by either the client or the server at any time after opening handshake completion and before that endpoint has sent a Close frame (Section 5.5.1).",
          "translation": "オープニングハンドシェイク完了後、そのエンドポイントがCloseフレームを送信する前であれば、クライアントまたはサーバのいずれからでもいつでもデータフレームを送信できる（MAY）（セクション5.5.1参照）。",
          "score": 0.587,
          "iterations": 2,
          "needs_review": true
        }
      ]
    },
    {
      "section": "5.2",
      "title": "Base Framing Protocol",
      "title_ja": "ベースフレーミングプロトコル",
      "paragraphs": [
        {
          "id": "5.2-p1",
          "source": "This wire format for the data transfer part is described by the ABNF [RFC5234] given in detail in this section.",
          "translation": "データ転送部分のワイヤフォーマットは、本セクションで詳述するABNF [RFC5234]により記述される。",
          "score": 0.941,
          "iterations": 1
        },
        {
          "id": "5.2-p2",
          "source": "(Note that, unlike in other sections of this document, the ABNF in this section is operating on groups of bits. The length of each group of bits is indicated in a comment. When encoded on the wire, the most significant bit is the leftmost in the ABNF).",
          "translation": "（本文書の他のセクションとは異なり、本セクションのABNFはビットグループで動作することに注意。各ビットグループの長さはコメントで示される。ワイヤ上でエンコードされるとき、最上位ビットはABNFで最も左側になる。）",
          "score": 0.8,
          "iterations": 1
        },
        {
          "id": "5.2-p3",
          "source": "A high-level overview of the framing is given in the following figure. In a case of conflict between the figure below and the ABNF specified later in this section, the figure is authoritative.",
          "translation": "フレーミングの高レベルな概要は以下の図に示される。以下の図と本セクションで後述するABNFの間に矛盾がある場合は、図が優先する。",
          "score": 0.85,
          "iterations": 1
        }
      ]
    },
    {
      "section": "5.3",
      "title": "Client-to-Server Masking",
      "title_ja": "クライアントからサーバへのマスキング",
      "paragraphs": [
        {
          "id": "5.3-p1",
          "source": "The masking key is a 32-bit value chosen at random by the client. When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame.",
          "translation": "マスキングキーは、クライアントがランダムに選択する32ビットの値である。マスク済みフレームを準備する際、クライアントは許可された32ビット値の集合から新しいマスキングキーを選択しなければならない（MUST）。マスキングキーは予測不可能である必要がある。したがって、マスキングキーは強力なエントロピー源から導出されなければならず（MUST）、特定のフレームのマスキングキーは、サーバ/プロキシが後続のフレームのマスキングキーを容易に予測できるようにしてはならない（MUST NOT）。",
          "score": 0.763,
          "iterations": 1,
          "needs_review": true
        }
      ]
    },
    {
      "section": "5.4",
      "title": "Fragmentation",
      "title_ja": "フラグメンテーション",
      "paragraphs": [
        {
          "id": "5.4-p1",
          "source": "The primary purpose of fragmentation is to allow sending a message that is of unknown size when the message is started without having to buffer that message. If messages couldn't be fragmented, then an endpoint would have to buffer the entire message so its length could be counted before the first byte is sent.",
          "translation": "フラグメンテーションの主な目的は、メッセージ送信開始時にそのサイズが不明であっても、メッセージをバッファリングすることなく送信できるようにすることである。メッセージをフラグメント化できない場合、エンドポイントは最初のバイトを送信する前にその長さを計算できるよう、メッセージ全体をバッファリングしなければならない。",
          "score": 0.952,
          "iterations": 1
        }
      ]
    },
    {
      "section": "5.5",
      "title": "Control Frames",
      "title_ja": "制御フレーム",
      "paragraphs": [
        {
          "id": "5.5-p1",
          "source": "Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.",
          "translation": "制御フレームは、オペコードの最上位ビットが1であるオペコードによって識別される。現在定義されている制御フレームのオペコードには、0x8（Close）、0x9（Ping）、0xA（Pong）が含まれる。オペコード0xB-0xFは、今後定義される制御フレームのために予約されている。",
          "score": 0.811,
          "iterations": 1
        }
      ],
      "subsections": [
        {
          "section": "5.5.1",
          "title": "Close",
          "title_ja": "Close"
        },
        {
          "section": "5.5.2",
          "title": "Ping",
          "title_ja": "Ping"
        },
        {
          "section": "5.5.3",
          "title": "Pong",
          "title_ja": "Pong"
        }
      ]
    },
    {
      "section": "5.6",
      "title": "Data Frames",
      "title_ja": "データフレーム",
      "paragraphs": [
        {
          "id": "5.6-p1",
          "source": "Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are reserved for further non-control frames yet to be defined.",
          "translation": "データフレーム（すなわち非制御フレーム）は、オペコードの最上位ビットが0であるオペコードによって識別される。現在定義されているデータフレームのオペコードには、0x1（Text）、0x2（Binary）が含まれる。オペコード0x3-0x7は、今後定義される非制御フレームのために予約されている。",
          "score": 0.91,
          "iterations": 1
        }
      ]
    },
    {
      "section": "5.7",
      "title": "Examples",
      "title_ja": "例",
      "note": "フレームバイト列の例示セクション。技術仕様のため翻訳省略"
    },
    {
      "section": "5.8",
      "title": "Extensibility",
      "title_ja": "拡張性",
      "paragraphs": [
        {
          "id": "5.8-p1",
          "source": "The protocol is designed to allow for extensions, which will add capabilities to the base protocol. The endpoints of a connection MUST negotiate the use of any extensions during the opening handshake.",
          "translation": "本プロトコルは、基本プロトコルに機能を追加する拡張を可能にするよう設計されている。接続のエンドポイントは、オープニングハンドシェイク中にすべての拡張の使用についてネゴシエーションしなければならない（MUST）。",
          "score": 0.721,
          "iterations": 1,
          "needs_review": true
        }
      ]
    }
  ],
  "averageScore": 0.84,
  "note": "全サブセクション完了"
}
