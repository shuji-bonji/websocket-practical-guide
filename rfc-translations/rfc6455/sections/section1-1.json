{
  "section": "1.1",
  "title": "Background",
  "source": {
    "text": "This section is non-normative.\n\nHistorically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].\n\nThis results in a variety of problems:\n\no  The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.\n\no  The wire protocol has a high overhead, with each client-to-server message having an HTTP header.\n\no  The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.\n\nA simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket Protocol provides. Combined with the WebSocket API [WSAPI], it provides an alternative to HTTP polling for two-way communication from a web page to a remote server.\n\nThe same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.\n\nThe WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication). Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for further discussion). The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment. However, the design does not limit WebSocket to HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol. This last point is important because the traffic patterns of interactive messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.",
    "language": "en"
  },
  "translation": {
    "text": "このセクションは非規範的である。\n\n歴史的に、クライアントとサーバ間の双方向通信を必要とするWebアプリケーション（例：インスタントメッセージングやゲームアプリケーション）の作成には、HTTPを悪用してサーバに更新をポーリングする一方で、上流への通知を個別のHTTP呼び出しとして送信する必要があった[RFC6202]。\n\nこれは様々な問題を引き起こす：\n\no サーバは各クライアントに対して複数の異なる基盤TCP接続の使用を強いられる：クライアントへの情報送信用に1つと、受信メッセージごとに新しい接続が必要となる。\n\no ワイヤプロトコルは高いオーバーヘッドを持ち、クライアントからサーバへの各メッセージがHTTPヘッダを持つ。\n\no クライアント側スクリプトは、応答を追跡するために送信接続から受信接続へのマッピングを維持することを強いられる。\n\nより単純な解決策は、双方向のトラフィックに単一のTCP接続を使用することである。これがWebSocketプロトコルの提供するものである。WebSocket API [WSAPI]と組み合わせることで、Webページからリモートサーバへの双方向通信においてHTTPポーリングの代替手段を提供する。\n\n同じ技術はゲーム、株価ティッカー、同時編集可能なマルチユーザアプリケーション、リアルタイムでサーバ側サービスを公開するユーザインターフェースなど、様々なWebアプリケーションに使用できる。\n\nWebSocketプロトコルは、既存のインフラストラクチャ（プロキシ、フィルタリング、認証）の恩恵を受けるためにHTTPをトランスポート層として使用する既存の双方向通信技術を置き換えるよう設計されている。HTTPは元来双方向通信での使用を意図していなかったため、このような技術は効率と信頼性のトレードオフとして実装された（さらなる議論については[RFC6202]を参照）。WebSocketプロトコルは既存のHTTPインフラストラクチャの文脈において既存の双方向HTTP技術の目標への対処を試みている。そのため、現環境に固有の複雑さを伴う場合でも、HTTPポート80および443上で動作するとともにHTTPプロキシや中間者をサポートするよう設計されている。しかしながら、この設計はWebSocketをHTTPに限定しておらず、将来の実装ではプロトコル全体を再発明することなく専用ポート上でより単純なハンドシェイクを使用できる。対話型メッセージングのトラフィックパターンは標準HTTPトラフィックと密接に一致せず一部コンポーネントに異常な負荷を誘発しうるため、この最後の点は重要である。",
    "language": "ja"
  },
  "evaluation": {
    "method": "paragraph-level",
    "paragraphScores": [
      { "paragraph": 1, "score": 0.842, "content": "intro + history" },
      { "paragraph": 2, "score": 0.961, "content": "simpler solution" },
      { "paragraph": 3, "score": 0.948, "content": "design goals" }
    ],
    "averageScore": 0.917,
    "note": "Full-text evaluation gives lower scores due to xCOMET's handling of long texts. Paragraph-level evaluation confirms quality above 0.8 threshold.",
    "passed": true
  },
  "iterations": 3,
  "completedAt": "2026-01-17"
}
